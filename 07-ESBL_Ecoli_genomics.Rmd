# Whole genome sequencing of ESBL _E. coli_ carriage isolates
\chaptermark{WGS of ESBL-E}

``` {r ch7-setup, include = F}

wd <- "chapter_7/"

# and packages
library(plyr)
library(tidyverse)
library(reshape2)
library(knitr)
library(kableExtra)
library(grid)
library(ggpubr)
library(ggtree)
library(ape)
library(phytools)
library(RColorBrewer)
library(scales)
library(cowplot)
library(pheatmap)
library(viridis)
library(ggraph)
library(igraph)


 parse_checkm_lines <- function(s, n) {
  strsplit(s, " ") -> stemp
  stemp <- stemp[[1]][stemp[[1]] != ""] 
  stemp <- c(stemp[1], paste0(stemp[2],"_", stemp[3]), stemp[4:15])
  names(stemp) <- n
  return(stemp)
 }


output = "latex"
source("other_scripts/load_metadata.R")
source("other_scripts/function_parse_cdhitest.R")
source("other_scripts/parse_blast_op_IRranges.R")


```
## Chapter overview

This chapter describes the use of whole-genome sequencing (WGS) of ESBL producing _E. coli_ to understand the drivers of gut mucosal ESBL-E carriage. I will begin with a description of the genomic landscape of the isolates form this study: starting with simple descriptions of _E. coli_ phylogroup and multilocus sequence type (MLST) I will place the isolates from this study in the context of the _E. coli_ population, followed by higher-resolution contextulaistaion using phylogenetics to place isolates from this study in the context of a global _E. coli_ collection. I will describe the genetic basis of antimicrobial resistance in these isolates and explore the extent to which AMR genes tend to cluster together beyond what would be expected by chance. Finally, I will attempt to use the resolution offered by WGS to attempt to answer two specific questions: firstly, what is the mechanism of rapid increase in ESBL-E carriage prevalence following hospital admission and antimicrobial exposure we see in this study? Secondly, what is the likely unit of ESBL-E transmission in this study? Are bacteria, or mobile genetic elements (MGE) implicated? And if, MGE, which: plasmids, transposons, integrons - or a combination?

These questions, phrased in this way, seem difficult or impossible to answer given the available WGS data, but by slightly reframing them they become tractable: first, what is the diversity of apparent hospital-acquired ESBL _E. coli_ in comparison to apparent community-acquired isolates? Apparent hospital acquisitions could represent true acquisitions of, for example, a hospital-associated clone - but equally they could be an "unmasking" of minority variant _E. coli_ in the microbiota, acquired in the community but not detected by culture because of low abundance, until enriched for by antimicrobial exposure. If the diversity of apparently hospital aquired isolates is contained within the diversity of community isolates, this would lend support to this latter hyothesis. The second question - what is the unit of transmission in this system - can be reframed by asking: what is the unit that is most conserved within patients, as compared to between patients?  The questions then reduce to a dimensionality redcution problem: in order to address them both, it is necessary to classify either bacteria or MGE into mutually exclusive categories, in order to compare hospital to community isolates, and between-patient to within-patient. I describe the approach I have taken to this below. 

## Methods

### Bioinformatic pipeline

The basic bioinformatic pipeline used is described in detail in Chapter 2, methods. Briefly, one _E. coli_ colony from each patient sample was taken forward for DNA extraction and paired-end short-read whole genome sequencing using Illumina HiSeq X at the Wellcome Sanger Institute. Read quality control was undertaken with Kraken[@Wood2014] v0.10.6 to assign reads to species and WSI QC pipeline which maps a random 100 Mbases fron each sample to a reference and calculates depth of coverage, number of heterogeneous SNPs, GC content and insert size. Samples that contained > 80% non _E coli._ reads were discarded and _de novo_ assembly was undertaken with SPAdes[@Bankevich2012a] v3.11.0. Assembly statistics were calculated with QUAST[@Gurevich2013] v4.6.0 and completeness and contamination of the assemblies assessed by checkM[@Parks2015] v1.0.7. Contaminated assemblies (with checkM-defined contamination of > 25%) or poor assemblies (with less than 1Mb assembled length) were discarded. Annotation was carried out with Prokka[@Seemann2014a] v1.5 with a genus specific database from RefSeq and the Roary v1.007 pan-genome pipeline[@Page2015] was used to identify a core genome. A core gene multiple sequence alignment was generated using maaft[@Katoh2013] v7.205, SNP-sites identified using SNP-sites[@Page2016] v2.4.1 and the resultant SNP alignment used to build a maximum likelihood phylogenetic tree using IQ-TREE[@Nguyen2015] v1.6.3, using ascertainment bias correction to correct for the fact that the input pseudosequence contained only variable sites, and using the ModelFinder module used to find the best fitting nucleotide substition model. This calculates the likeliood of a number of different models and chooses the model with the lowest (best fitting) Bayesian Information Criterion, a statistic which penalises model parameters. Reliability of inferred branch partitions was assessed with 1000 bootstrap replicates. Trees were visualised in the ggtree v1.14.4 package[@Yu2017] in R. 

ARIBA[@Hunt2017a] v2.12.1 was used to identify AMR-associated genes using the SRST2[@Inouye2014] database, to identify plasmid replicons using the PlasmidFinder database[@Carattoli2014] and to perform _in silico_ muli-locus sequence typing (MLST) using the database from http://mlst.warwick.ac.uk/mlst/dbs/Ecoli accessed via www.pubmlst.org. The $\beta$-lactamase genes $ampC1$, $ampC2$ and $ampH$ were excluded from the analysis of AMR determinents as they do not usually cause a resistant phenotype in _E. coli_. Because quinolone resistance often results from SNPs in the chromasome in the quinolone resistance determining regions (QRDRs) of the _gyrA_, _gyrB_, _parE_ and _parC_ genes - rather than acquisition of whole AMR-determining genes, as is the case with the other genes sought by Ariba - these genes were downloaded from the comprehensive antimicrobial resistance database (CARD, https://card.mcmaster.ca/) and Ariba used to call SNPs in them, with default settings. _E. coli_ phylogrouping was performed with a quadruplex _in silico_ PCR using the Clermont scheme[@Clermont2013] and isPcr v33x2 (https://github.com/bowhan/kent/tree/master/src/isPcr) 

_Rhierbaps_ package v1.1.0 in R[@Cheng2013] was used to cluster the core genome pseudosequence into sequence clusters (SCs). Two levels were used and these level 2 clusters used to test associations (see statistical analysis, below). To track putative mobile genetic elements ESBL-gene containing contigs were identified using _BLASTn_[@Altschul1990] v2.7.0 of all contigs against the SRST2 database and then contigs containing any given ESBL gene  were grouped by the ESBL gene they contained (for example, all $bla_{ctxm15}$ gene-containing clusters were grouped together), and each group clustered using _cd-hit_[@Li2006] v4.6 to produce mutually exclusive ESBL-gene-containing contig clusters for each identified ESBL gene. Henceforth, these clusters will be referred to as ESBL-clusters, for brevity. In order to attempt to determine the biological significance of the identified ESBL-clusters (i.e. what kind of MGE element they are likely to represent), basic statistics were plotted (number of samples contained withing each cluster, length of longest contig in cluster in kbases, length distribution of all contigs is cluster relative to longest contig and distribution of sequence identity compared to the longest contig in the cluster). Presence of insertion sequences (i.e compound transposons), AMR determinents and plasmid replicons were identified by using BLAST with default settings of each ESBL-cluster representative sequence (as determined by cd-hit i.e one, the longest, for each ESBL-cluster) against the insertion sequence finder (ISfinder) database and the SRST2 database, filtering such that sequence identify was greater or equal to 95%, taking the top hit (as determined by bitscore) for any given location if there were two overlapping hits, and visualising the results in _gggenes_ v0.3.2. To assess lineage association, the ESBL-clusters were mapped back to the core genome phylogeny. 

### Global _E. coli_ collection

In order to place the isolates from this study in a global context, published _E. coli_ assemblies were downloaded from the WSI servers. These included 149 ESBL-producing _E. coli_ from a single centre study in Chachoengsao province, eastern Thailand[@Runcharoen2017]. In this study, human clinical isolates from standard care in Bhuddhasothorn hospital were selected on the basis of the ESBL phenotype, and environmental samples were collected as part of a cross sectional study and selectively cultured for ESBL-E in 2014-2015. I also downloaded assemblies of 362 enterotoxogenic _E. coli_ (ETEC), selected for an ETEC genomic study from the Gothenburg University ETEC collection to represent a broad collection of ETEC isolated worldwide from 1980-2011[@VonMentzer2014]; 185 atypical enteropathogenic _E. coli_ (aEPEC) sequenced for a study of aEPEC and selected from samples frrm the Global Enteric Multicentre Study (GEMS) in seven centres in Africa and Asia between 2007-2011[@Ingle2016]; and 94 _E. coli_ from QECH in Blantyre, Malawi, a combination of invasive (bloodstream and CSF) and carriage isolates, selected for diversity in AMR phenotype from 1996-2014[@Musicha2017]. Details of the year, sample andcountry of isolation for these samples are given in the appendix to this chapter.

Phylogroup and MLST were determined for these context genomes as described above. AMR genes were identified with Ariba and the SRST2 database, as above, and context genomes were classified as ESBL if they contained any Bush-Jacoby group 2be ESBL gene .

### Statistical analysis

Ability of presence or absence of resistance determinents to predict phenotypic resistance as determined by antimicrobial sensitivity testing was expressed as sensitivity and specifcity, with exact binomial confidence intervals. In order to explore clustering of AMR genes, the Jaccard index was calculated for a given AMR-gene pair using he _jaccard_ v0.1.0 package in R. The Jaccard index, a measure of the similarity of two sets of data, is defined as _intersection over union_; in this context, for a given pair of AMR genes $x$ and $y$, the Jaccard index $J(x,y)$ is the number of isolates that contain both gene $x$ and $y$ divided by the total number that contain either $x$ or $y$:

$$J(x,y) = \displaystyle \frac{| x \cap y |}{| x \cup y| }$$

By definition it lies between 0 ($x$ and $y$ never co-occur) and 1 ($x$ and $y$ always co-occur). Co-occurance matrices using the Jaccard index were plotted using the _pheatmap_ v1.0.12 package in R. The statistical significance of co-occurance of genes was assessed by generating 2x2 contingency tables for a given gene pair and p values generated using a Fisher's test with Bonferroni correction; a p value of less that 0.05 was considered statistically significant. Co-occurance networks of genes occuring commonly together (defined as Jaccard index > 0.5) at a rate greater than expected by chance (p < 0.05 following Bonferroni correction) were plotted using _igraph_ v1.2.2 and _ggraph_ v1.0.2 in R.

To explore hospital or community associations of any given _E. coli_ clade, the location of isolation was first plotted against the phylogenetic tree; location of isolation was classified as hospital, community, or recent hospital discharge (defined as a date of isolation within 2 weeks of hospital discharge). This latter category was used because it is possible that a patient could acquire an ESBL-E clone in hospital but only be sampled once leaving hospital; using only hospital isolated and community isolted categories could therefore introduce bias. Hospital or community association of each sequence cluster was assessed using a Fisher's exact test of proportion of hospital associated samples (defined as sum of hospital isolated and recent hospital discharge) for the given sequence cluster as compared to proportion of hospital associated samples in the remainder of the samples, with a Bonferroni correction for multiple comparisons. p < 0.05 was again considered statistically significant.

To compare within-patient to between-patient conservation of bacteria (as represented by core genome alignment and sequence cluster) and ESBL-containing MGE (as represented by the ESBL-clusters) several approaches were taken. Firstly, I assessed whether either sequence cluster or ESBL-cluster were conserved within an individual at all. I hypothesised that any within-patient correlation is likely to be a function of time: samples closer together in time may be more likely to be similar. To assess if this was the case for bacteria, pairwise core genome pseudosequence SNP distance was was calculated using _snp-dists_ v0.4 (https://github.com/tseemann/snp-dists) for all samples and plotted against the time difference (in days) between samples, within and between patients, and with a smoothed curve fitted using a general additive model with cubic splines. Because of significant overplotting, this was also plotted as a 2D density plot. Based on these plots, the within and between patient SNP distances were compared in two post-hoc defined groups binned by time distance between the samples (50 days or less vs. more than 50 days), and distributions compared with Kruskal-Wallace tests.

I then compared the within patient temporal clustering of ESBL-clusters and sequence clusters, by estimating the proportion of within-patient samples that contain the same ESBL-cluster or sequence cluster, as a function of time; essentially a temporal autocorrelation function. To estimate this, I considered pairwise comparsion of all within-patient samples. For any given time between samples, $t$ I defined a window of +/-5 days and estimated the probabilities as the number of all within-patient sample pairs in the window $[t - 5, t+5]$ that contained the same sequence cluster or ESBL-cluster divided by the total number of all within-patient sample pairs within that time window. Exact binomial confidence intervals for these proportions were generated and probabilities plotted as a function of time. In order to estimate the probability of two samples containing the same sequence cluster of contig-cluster purely by chance, 1000 sample pairs were randomly drawn from all samples with replacement and the proportion of these samples that contained the same sequence cluster or ESBL-cluster calculated.

Finally, to inform the question as to what the likely unit of transmission in this system is, I assessed what was most conserved within patients, in pairwise sample comparison: bacteria (as represented by core gene sequence cluster), ESBL-containing MGE (as represented by ESBL-cluster), or both. Simple proportions in all-against-all pairwise comparison - stratified by whether between-patient or within-patient - were calculated: the proportion of samples that contain the same core gene sequence cluster only, the proportion of samples contain the same ESBL-cluster only, and the proportion that contain both sequence cluster and ESBL-cluster. Proportions were compared between within and between-patient strata in these three groups using Fisher's exact test, with p < 0.05 considered statistically significant.

## Results

### Samples and quality control

In total, 520 _E. coli_ underwent DNA extraction and were shipped from Malawi to WSI; these represented all sequential isolates at the time of final DNA extraction, which occured in two batches in February 2018 and October 2018. Kracken/Bracken read assignment of these samples is shown in Figure \@ref(fig:wgs-qc-braken). The majority of samples have > 90% or reads assigned to _E. coli_; a minority have < 90% of reads assigned to _E. coli_ but a very closely related species such as _Shigella_, amd as such are likely to be pure _E. coli_ culture with read misclassification. However, 12 samples have > 80% reads assigned to a non- _E. coli_ species such as _Klebsiella pneumoniae_. These samples were assumed to represent upstream species misidentification or, perhaps more likely, selection of the wrong sample from the freezer archive for culture and DNA extraction, given that for any sample ID there are often several bacterial species identified and cryopreserved. These samples were excluded from further analysis.

```{r wgs-qc-braken,  echo = F, warning = F, message = F, fig.scap="Species read assignment of sequenced isolates", out.extra='', fig.cap= "Species read assignment of all samples", fig.align= "center",fig.height = 10, fig.width = 6 }

df1 <- read_tsv(paste0(wd, "D1_Braken_readscreen_species_composition.tsv"))
df2 <- read_tsv(paste0(wd, "D2_Bracken_species_composition.tsv"))
df3 <- read_tsv(paste0(wd, "D2_extra_krakenout_species_composition_16.tsv"))

df.brac <- bind_rows(df1, df2, df3)
df.brac[is.na(df.brac)] <- 0

melt(df.brac, id.vars = "name") -> dftemp

dftemp$variable <- factor(dftemp$variable, levels = unique(dftemp$variable[order(as.character(dftemp$variable))]))

dftemp$name <- factor(dftemp$name, levels = df.brac$name[order(df.brac$`Escherichia coli`, decreasing = T)])

ggplot(dftemp, aes(name, value, fill = variable)) + geom_col() + coord_flip() + scale_fill_brewer(palette = "Paired") +  theme_bw() + theme(axis.text.y = element_text(size = 2), legend.title = element_blank(), legend.text = element_text(size = 8)) + labs(x= "Sample ID", y = "% reads" ) 




```

```{r wgs-load-qc,  echo = F, warning = F, message = F}

# load sanger QC

df1 <- read.csv(paste0(wd, "5341.pathfind_stats.csv"), stringsAsFactors = F)
df2 <- read.csv(paste0(wd, "5510.pathfind_stats.csv"), stringsAsFactors = F)

#df2$`No. Het SNPs`<- as.numeric(df2$`No. Het SNPs`)

df.qc <- rbind(df1, df2)


# laod checkM

con <- file(paste0(wd, "checkm_quast/D1/checkm.report"))
lines <- readLines(con)
close(con)

con <- file(paste0(wd, "checkm_quast/D220190318/checkm.report"))
lines2 <- readLines(con)
close(con)

con <- file(paste0(wd, "checkm_quast/D220190503/checkm.report"))
lines3 <- readLines(con)
close(con)

# line 2 has headings - get em
strsplit(lines[[2]]," ") -> heads
heads[[1]][heads[[1]] != "" & heads[[1]] != "#"] -> heads

# sigh
heads <- c(paste0(heads[1], "_", heads[2]), paste0(heads[3], "_", heads[4]), heads[5:6],
           paste0(heads[7],"_",heads[8]), heads[9:16], paste0(heads[17], "_", heads[18]))

lines <- lines[-c(1,2,3, length(lines))]
lines2 <- lines2[-c(1,2,3, length(lines2))]
lines3 <- lines3[-c(1,2,3, length(lines3))]
 
 

lines <- lapply(lines, parse_checkm_lines, heads)
lines2 <- lapply(lines2, parse_checkm_lines, heads)
lines3 <- lapply(lines3, parse_checkm_lines, heads)

lines <- data.frame(do.call(rbind, lines))
lines2 <- data.frame(do.call(rbind, lines2))
lines3 <- data.frame(do.call(rbind, lines3))

lines <- rbind(lines, lines2, lines3)
rm(lines2)
rm(lines3)
lines[3:ncol(lines)] <- sapply(lines[3:ncol(lines)], function(x) as.numeric(as.character(x)))

names(lines)[names(lines) == "Bin_Id"] <- "Assembly"

#sub( "_1_", "_1#", q$Assembly) -> q$Assembly
sub(".contigs_spades", "", lines$Assembly) -> lines$Assembly

checkm <- lines
rm(lines)

## and quast
rbind(
  read.delim(paste0(wd, "checkm_quast/D1/transposed_report.tsv"), stringsAsFactors = F ),
  read.delim(paste0(wd, "checkm_quast/D220190318/transposed_report.tsv"), stringsAsFactors = F ),
  read.delim(paste0(wd, "checkm_quast/D220190503/transposed_report.tsv"), stringsAsFactors = F )
  ) -> quast

for (i in 1:10) {
sub("\\.", "", names(quast)) -> names(quast)
}

sub(".contigs_spades","", quast$Assembly) -> quast$Assembly
sub("_1_","_1#", quast$Assembly) -> quast$Assembly
sub("_2_","_2#", quast$Assembly) -> quast$Assembly

df.qc <- merge(df.qc, df.brac, by.x = "Lane.Name", by.y = "name", all.x = T)
df.qc <- merge(df.qc, checkm, by.x = "Lane.Name", by.y = "Assembly", all.x = T)
df.qc <- merge(df.qc, quast, by.x = "Lane.Name", by.y = "Assembly", all.x = T)

# remove non ESCO

df.qc <- subset(df.qc, `Escherichia coli` > 20)


```

Of the remaining 508 samples, there were a median (IQR) of `r paste0(median(df.qc$Reads), " (", quantile(df.qc$Reads, 0.25)[[1]], "-", quantile(df.qc$Reads, 0.75)[[1]], ")")` reads, with a median (IQR) depth of coverage (obtained by mapping a random 100Mbases to a refernce _E. coli_ genome, Escherichia coli strain K-12 substrain MG1655, NCBI reference NC_000913.3) of `r paste0(round(median(df.qc$Depth.of.Coverage)), " (", round(quantile(df.qc$Depth.of.Coverage, 0.25)[[1]]), "-", round(quantile(df.qc$Depth.of.Coverage, 0.75)[[1]]), ")")`. One sample had an order of magnitude lower number of reads (291556) with depth of coverage 0; this was assumed to represent sequencing failure and it was excluded from further analysis.

The output from quast and checkM are shown in Figure \@ref(fig:wgs-qc), where N50 (the minimum contig length upon which at least half assembled bases are contained) is plotted as a function of total assembled length. The expected _E. coli_ genome length is around 4.6Mb and most samples cluster close to this at a total assembled length of ~ 5Mb. Howvever it is clear that some assemblies  have failed, with low N50 and low assembled length. It is also apparent that some samples seem to be contaminated, as indicated by low N50 and much longer than expected total assembled length. Defining assembly failure as < 1Mb assembled length (triangles in the plot, n = 9) and contamination as checkM-defined contamination of > 25% (blue points in the plot, n = 24) and excluding both groups results in 33 further samples being excluded from further analysis.

In total, therefore, 46/520 (11%) of samples which were submitted for sequencing were excluded from downstream analysis. The remaining 474 samples represent 69% (474/686) of the cutured _E. coli_ in this study; 354 are from patients with sepsis, 86 are from hospitalised inpatients and 33 are from community members, with a median of 2 (range 1-5) samples per participant. N50, total assembled length and number of assembled contigs are shown in the appendix to this chapter.

```{r wgs-qc, echo = F, warning = F, message = F, fig.scap="N50 as a function of total assembly length for included assemblies", out.extra='', fig.cap= "N50 as a function of total assembled length. Failed assemblies with less than 1Mb assembled shown as triangles. Contaminated assemblies with checkM-defined contamination above 25\\% shown in blue.", fig.height = 3, fig.width = 5, fig.align="center"  }

df.qc <- subset(df.qc, Reads > 300000)

ggplot(df.qc, aes(Totallength, N50, colour = Contamination > 25, shape = Xcontigs < 10)) + geom_point() + theme_bw() + labs(shape = "< 1Mb assembled", colour = "Contamination > 25%", x = "Total assembled length (bp)") 

```

```{r wgs-mlst-pgroup, echo = F, warning = F, message = F }

mlst <- read_csv(paste0(wd, "phylogroup_and_mlst/mlst.csv"))
pgroups <- read_csv(paste0(wd, "phylogroup_and_mlst/phylogroups.csv"))
```

### Phylogroup, MLST and core genome phylogeny of study isolates

The commonset _E. coli_ phylogroup was phylogroup A: 204/473 (43%) samples belonged to phylogroup A, followed by phylogroup B2 (96/473 [20%]), F (53/473 [11%]), B1 (43/473 [9%]) and C (43/473 [9%]) and D (26/473 [5%]). Two samples were Clade I or II (so called cryptic clades) and 6/473 (1%) were unknown phylogroup using the Clermont PCR scheme. In the MLST analysis, 56 recognised sequence types (STs) were identified, and 12 samples were novel STs; however over half (249/473 [53%]) of samples were represented by the top seven most frequent STs (Figure \@ref(fig:wgs-mlst)). ST131 was the most commonly isolated sequence type (64/473 [14%] of isolates) followed by ST410 (45/473 [10%] of isolates) and ST167 (38/473 [8%] of isolates).

The Roary pan-genome pipeline identified a core genome in the study isolates of 2966 genes, with a pan-genome of 26840 genes. The resultant core gene pseudosequence of length 1388742 bases contained 99693 variable sites, which were used to infer the maximum likelihood phylogenetic tree. The IQTREE ModelFinder module determined that a general time reversible (GTR) model with FreeRate site heterogeneity with 5 parameters provided the best fit to the data. The inferred tree is shown in Figure \@ref(fig:wgs-mlst) along with isolate phylogroup and sequence types; in general, as expected, sequence types were largely monophyletic and phylogroups tended to cluster together.

```{r wgs-mlst, echo = F, warning = F, message = F, fig.cap="\\textit{E. coli} Multilocus sequence type distribution", fig.height = 2, fig.width=6}

ggplot(mlst, aes(fct_infreq(ST))) + geom_bar()+
  xlab("E. coli sequence type") + ylab("Count") + theme_bw() + theme(axis.text.x=element_text(size=5, angle = 90) )

```

```{r wgs-tree, echo = F, warning = F, message = F, fig.scap="ML phylogenetic tree of study \\textit{E. coli}", out.extra='', fig.cap="Maximum likelihood phylogenetic tree of included study \\textit{E. coli} isolates showing phylogroups and sequence types. Bootstrap support of less than 90\\% is indicated by a black circle at a given node. Scale bar indicates 0.01 SNPs/site.", fig.height = 10, fig.width=8}

tree <- read.tree(paste0(wd, "core_genome_tree/core_alnD2ESCO_snp_sites.aln.treefile"))
midpoint.root(tree) -> tree

rownames(pgroups) <- pgroups$Lane
reshape2::dcast(mlst, lane ~ ST, fun.aggregate = base::length) -> mlst.onehot
#mlst.onehot <- subset(mlst.onehot, lane %in% tree$tip.label)

rownames(mlst.onehot) <- mlst.onehot$lane
mlst.onehot <- select(mlst.onehot, -lane)
n.mlsts <- sort(apply(mlst.onehot,2, sum), decreasing = T)
mlst.onehot[names(n.mlsts[n.mlsts > 1])] -> mlst.onehot

apply(mlst.onehot, 1, sum) == 0 -> mlst.onehot$other
mlst.onehot$other<- as.numeric(mlst.onehot$other)



mlst.onehot[mlst.onehot == 0] <- "Z_No"
mlst.onehot[mlst.onehot == 1] <- "Z_Yes"






#mlst.onehot[c(sort(as.numeric(names(mlst.onehot)[names(mlst.onehot) != "Novel"])), "Novel")] -> mlst.onehot


col <- c(hue_pal()(8), "lightgrey", "black")
names(col) <- c("A","B1","B2","C","Clade I or II", "D","F", "Unknown", "Z_No", "Z_Yes")

ggtree(tree) %>% gheatmap(select(pgroups, Phylogroup), font.size = 3, width = 0.1, 
                          colnames_position = "top", color = NA, colnames_offset_y = 5) +
  scale_fill_manual(values =col, labels = c("A","B1","B2","C","Clade I/II", "D","F", 
                                            "Unknown", "Absent", "Present"))-> p1x

leg1 <- get_legend(p1x)

ggtree(tree) %>% gheatmap(select(pgroups, Phylogroup), width = 0.1, 
                          color = NA, font.size = 4, colnames_angle = 90,
                          colnames_position = "top", colnames_offset_y = 30)  %>% gheatmap((mlst.onehot), font.size = 2.5, color = NA, 
                          colnames_angle = 90, offset=.03, colnames_offset_y = 10, colnames_position = "top",)  + geom_treescale(x =0, y = 0, offset = 5)  +   geom_point2(aes(subset = as.numeric(label) < 90 & !isTip), size = 1) + theme(legend.position = "none") +
  scale_fill_manual(values =col, labels = c("A","B1","B2","C","Clade I or II", "D","F", 
                                            "Unknown", "Absent", "Present")) + annotate("text", x= 0.28, y =510, label = "Sequence Type") -> p

plot_grid(p, leg1, ncol = 2, rel_widths = c(1,0.1))


```

### Study isolates in a global context

The global collection of _E. coli_ comprised 1273 samples, including the 473 from this study. 753/1253 (60%) were from Africa, 335/1253 (27%) from Asia and 167 (13%) from South America. The majority of samples, 1026/1253 (82%), were from stool, with 106/1253 (8%) truly invasive samples from blood or CSF and 63/1253 (5%) possibly invasive samples from urine, pus, or sputum. 65/1253 (5%) of samples were environmental, all from Thailand. 670/1253 (53%) of samples contained at least one ESBL-encoding gene. The majority of isolates with ESBL gene (622/670 [92%]) came from this study or the Thai ESBL study. Phylogroup A was the commonest phylogroup in the global collection (482/1273 [38%]), followed by B1 (333/1273 [26%]) and B2 (191/1273 [15%]); phylogroup C was uncommon in the global collection (74/1273 [6%]) but the majority of the phylogroup C samples came from this study (43/74 [58%]). All of these 43 phyogroup C isolates belonged to a single ST, ST410; this ST was not seen at all in the previous Malawian study of largely invasive isolates, despite beingthe second-commonest ST in this study. ST131 was again the commonest ST in the global collection.

The Roary pan-genome pipeline identified 2872 core genes in a pan genome of 44840 genes; this large pan-genome is consistent with the open _E. coli_ pan genome that will continue to increase in size as isolates are added. The core gene alignment contained 604817 bases with 77194 variable sites, which were used to infer the maximum likelihood phylogenetic tree, using same nucleotide substitution model as previously.

The inferred tree is shown in Figure \@ref(fig:wgs-global-tree)). Isolates from this study are distributed throughout the tree, and there is widespread mixing of isolates from diverse geographic regions. Though invasive isolates are spread throughout the tree, there is a tendance for them to cluster together, particularly in phylogroup B2, a phylogroup with has a recognised association with ExPEC (needs ref). The Malawian ST410 isolates clusterd tightly together, though are most closely related to clinical ESBL-procucing ST410 isolates from Thailand. By comparison, ST131 isolates from this study were distributed amongst ST131 isolates from other studies, both in Malawi and elsewhere.

```{r wgs-global-tree, echo = F, warning = F, message = F, fig.scap="ML phylogenetic tree of study \\textit{E. coli} in global context", out.extra='', fig.cap="Midpoint rooted maximum likelihood phylogenetic tree of included study \\textit{E. coli} isolates along with global context isolates, showing phylogroups, source sample type and continent of isolation (coloured bars). Dark grey bars indicate isolates from this study or isolates with ESBL gene presence, as labelled (this study or ESBL, respectively). Two most frequently isolated STs (131 and 410) labelled.  Bootstrap support of less than 90\\% is indicated by a black circle at a given node. Scale bar indicates 0.009 SNPs/site.", fig.height = 10, fig.width=8}


tree <- read.tree(paste0(wd, "global_tree/all_ESCO_core_snps.aln.treefile"))

midpoint.root(tree) -> tree

#metadata

metadata <- read_csv(paste0(wd, "global_tree/all_ESCO_metadata.csv"))
sub("#", "_", metadata$Lane.Name ) -> metadata$Lane.Name
metadata <- data.frame(metadata)
rownames(metadata) <- metadata$Lane.Name

metadata$Continent <- NA
metadata$Continent[metadata$Country == "Argentina" |
                     metadata$Country == "Bolivia" |
                     metadata$Country == "Guatemala" |
                     metadata$Country == "Mexico" |
                     metadata$Country == "Venezuela" ] <- "Z_S. America"

metadata$Continent[metadata$Country == "Bangladesh" | 
                     metadata$Country == "Burma" |
                     metadata$Country == "China" |
                     metadata$Country == "India" |
                     metadata$Country == "Indonesia" |
                     metadata$Country == "Japan" |
                     metadata$Country == "Nepal" |
                     metadata$Country == "Pakistan" |
                     metadata$Country == "thailand" |
                     metadata$Country == "Thailand"] <- "Z_Asia"

metadata$Continent[metadata$Country == "Egypt" | 
                     metadata$Country == "Gambia" |
                     metadata$Country == "Guinea Bissau" |
                     metadata$Country == "Kenya" |
                     metadata$Country == "Malawi" |
                     metadata$Country == "Mali" |
                     metadata$Country == "Morocco" |
                     metadata$Country == "Mozambique" |
                     metadata$Country == "Tunisia" |
                     metadata$Country == "Zaire"] <- "Z_Africa"

metadata$source.cat <- metadata$Source

metadata$source.cat[metadata$source.cat == "Canal" |
                      metadata$source.cat == "Farm" |
                      metadata$source.cat == "Untreated hospital sewage"] <- "_Environment"

metadata$source.cat[metadata$source.cat == "Blood" |
                      metadata$source.cat == "CSF"] <- "_Clinical - _Blood/CSF"

metadata$source.cat[metadata$source.cat == "Urine" |
                      metadata$source.cat == "Pus" |
                      metadata$source.cat == "Sputum" ] <- "_Clinical - Other"

metadata$source.cat[metadata$source.cat == "stool" |
                      metadata$source.cat == "Stool" |
                      metadata$source.cat == "RS"] <- "_Clinical - _Stool"

metadata$malawi <- as.factor(as.numeric(metadata$Country == "Malawi"))

metadata$this_study <- as.factor(as.numeric(grepl("DASSIM", metadata$study)))
# pgroups

pgroups <- read.csv(paste0(wd, "global_tree/phylogroups_and_mlst/all_ESCO_pgroups.csv"), stringsAsFactors = F)
pgroups.d <- read.csv(paste0(wd, "phylogroup_and_mlst/phylogroups.csv"), stringsAsFactors = F)
pgroups <- select(pgroups, V1, phylogroup)
names(pgroups) <- c("Lane", "Phylogroup") 
pgroups <- rbind(pgroups, pgroups.d)
rownames(pgroups) <- pgroups$Lane
pgroups$Phylogroup[pgroups$Phylogroup == "Clade I"] <- "Clade I or II"

# mlst


## load mlst and plot

mlst.d <- read.csv(paste0(wd, "phylogroup_and_mlst/mlst.csv"), stringsAsFactors = F)
mlst <- read.csv(paste0(wd, "global_tree/phylogroups_and_mlst/mlst_summary.csv"), stringsAsFactors = F)
mlst <- select(mlst, lane, ST)

mlst <- rbind(mlst.d, mlst)
dcast(mlst, lane ~ ST, fun.aggregate = base::length) -> mlst.onehot
#mlst.onehot <- subset(mlst.onehot, lane %in% tree$tip.label)

rownames(mlst.onehot) <- mlst.onehot$lane
mlst.onehot <- select(mlst.onehot, -lane)
n.mlsts <- sort(apply(mlst.onehot,2, sum), decreasing = T)
mlst.onehot[names(n.mlsts[n.mlsts > 1])] -> mlst.onehot

apply(mlst.onehot, 1, sum) == 0 -> mlst.onehot$other
mlst.onehot$other<- as.numeric(mlst.onehot$other)
mlst.onehot[mlst.onehot == 0] <- "Z_No"
mlst.onehot[mlst.onehot == 1] <- "Z_Yes"

#### AMR

srst2 <- read.csv(paste0(wd, "global_tree/srst2/srst2_summary_cleaned_pres_abs.csv"), stringsAsFactors = F)
srst2.d <- read.csv(paste0(wd, "amr/srst2_pres_abs.csv"), stringsAsFactors = F)
bind_rows(srst2, srst2.d) -> srst
srst[is.na(srst)] <- 0
rownames(srst) <- srst$name

narrow_spec <- c("TEM_1", "TEM_95", "TEM_135", "TEM_90",
                 "OXA_1", 
                 "SHV_1")

esbl <- c(names(srst)[grepl("CTX", names(srst))], 
          names(srst)[grepl("TEM", names(srst))],
          names(srst)[grepl("OXA", names(srst))],
          names(srst)[grepl("SHV", names(srst))],
          names(srst)[grepl("NDM", names(srst))])

esbl <- esbl[!(esbl %in% narrow_spec)]
data.frame(esbl = apply(srst[esbl], 1,sum)) -> esbl.cat
esbl.cat$esbl[esbl.cat$esbl > 0] <- 1
esbl.cat$Lane <- rownames(esbl.cat)
esbl.cat$esbl <- as.factor(esbl.cat$esbl)
##

col <- c(hue_pal()(8), "white", "grey30", brewer.pal(4,"Set1"),brewer.pal(4,"Dark2") )
names(col) <- c("A","B1","B2","C","Clade I or II", "D","F", "Unknown",
                "0", "1","_Clinical - _Blood/CSF", "_Clinical - _Stool", "_Environment",  "_Clinical - Other",
                "Z_Africa", "Z_Asia", "Z_S. America"
               )

names(metadata)[names(metadata) == "this_study"] <- "This study"
names(esbl.cat)[names(esbl.cat) == "esbl"] <- "ESBL"
names(metadata)[names(metadata) == "Source"] <- "Source1"
names(metadata)[names(metadata) == "source.cat"] <- "Source"

ggtree(tree, size = 0.3) %>% 
  gheatmap(select(metadata, `This study`), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80,offset = 0.006 ) %>%
  gheatmap(select(pgroups, Phylogroup), width = 0.05, 
           color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.001)  %>%
  gheatmap(select(esbl.cat, ESBL), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.011 ) %>%
  gheatmap(select(metadata, Source), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.016 ) %>%
  gheatmap(select(metadata, Continent), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.021 ) +
 # gheatmap(select(metadata, malawi), width = 0.04, color = NA, font.size = 4, colnames_angle = 90,
      #     colnames_position = "top", colnames_offset_y = 80, offset = 0.025 )+ 
  scale_fill_manual(values =col) + theme(legend.position = "none") +
  geom_treescale(x =0.02, y = 1100, offset = 5)  +   
  geom_point2(aes(subset = as.numeric(label) < 90 & !isTip), size = 0.3)+ 
  geom_cladelabel(node = 1351, label = "ST131", fontsize = 2.5) + 
  geom_cladelabel(node = 1866, label = "ST410", fontsize = 2.5) -> p #, labels = c("0", "1","A","B1","B2","C","Clade I or II", "D","F", 
    
ggtree(tree) %>% 

  gheatmap(select(pgroups, Phylogroup), width = 0.05, 
           color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80) +
  scale_fill_manual(values =col) + labs(fill = "Phylogroup") + theme(legend.title = element_text()) -> p1x

leg.pgroup <- get_legend(p1x)

ggtree(tree) %>% 
  
  gheatmap(select(metadata, Source), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.015 ) +
  scale_fill_manual(values =col, labels = c("Clinical: Blood/CSF", "Clinical: Stool", "Clinicial: Other", "Environment", "")) + labs(fill = "Source") + theme(legend.title = element_text())-> p1x
  
leg.source <- get_legend(p1x)

ggtree(tree) %>% 
  
  gheatmap(select(metadata, Continent), width = 0.05, color = NA, font.size = 4, colnames_angle = 90,
           colnames_position = "top", colnames_offset_y = 80, offset = 0.020 ) +
  scale_fill_manual(values =col, labels = c("Africa", "Asia", "S. America","")) + labs(fill = "Continent") + theme(legend.title = element_text())-> p1x

leg.continent <- get_legend(p1x)

ggarrange(p, 
          ggarrange(NULL, leg.pgroup, leg.source, leg.continent, NULL, ncol = 1, nrow = 5, heights = c(1,1,0.7,0.4,1)),
          ncol = 2, nrow = 1, widths = c(3,1))

```

### Antimicrobial resistance determinents

All identified AMR genes are shown in Figure \@ref(fig:wgs-amr-sum)A, alongside a summary of number of isolates with resistnce mutations to given antimicrobial classes (Figure \@ref(fig:wgs-amr-sum)B) and the phenotypic resistance of the isolates for which phenotypic antimicrobial resistance testing was carried out (449/473 [95%]). A description of resistance gene by class, along with a consdideration of concordance (or otherwise) of phenotypic resistance and predicted resistance from genotype, are given in turn below.

#### $\beta$-lactam resistance

All isolates contained at least one gene that conferred resistance to third-generation cephalosporins, either an ESBL gene (n= 472) or a carbapenamase (n=1). The majority of ESBL-gene containing isolates contained only one ESBL gene (459/472 [97%]); fewer contained 2 (13/472 [3%]) and none contained more than 2. $bla_{CTX-M}$ was the commonest ESBL gene, and over two thirds (319/473 [67%]) of isolates contained $bla_{CTX-M-15}$. ESBL $bla_{SHV}$ (26/473 [5%] of isolates) genes were also seen. ESBL $bla_{TEM}$ (1/473 isolates) and $bla_{OXA}$ (1/473 isolates) were very unusual; however, narrow spectrum $bla_{TEM}$ and $bla_{OXA}$ $\beta$-lactamases were common: $bla_{OXA-1}$ and $bla_{TEM-95}$ were present in 186/473 [39%] and 289/473 [61%] of isolates respectively. Plasmid-mediated $bla_{ampC}$ genes were identified in 45/473 (9%) of isolates, almost all (44/45) $bla_{CMY-42}$; this was unexpected as all of these isolates were comfirmed to be ESBL-producers by combination disc testing. This testing uses cephalosporin-containing discs both with and without clavulanic acid, and confirms EBSL production by a difference in zone size between these discs, as ESBL enzymes are inactivated by clavulanic acid. However, the cephalosporins used in this test are likely to be hydrolysed by $ampC$ enzymes, and if these isolates were producing such enzymes it could confer cephalosporin resistance regardless of the presence or absence of clavulanic acid. This was not the case for any of these isolates; none of them hydorolised the cephalosporins used in the presence of clavulanic acid. It may be that the $bla_{CMY}$ genes were not expressed.

The carbapenamase gene identified was s $bla_{NDM-5}$; the isolate harbouring this gene was recovered from the  stool of a 67-year old man with no history of foreign travel nor hospitalistion. He had been admitted to the hospital with fever seven days previously and treated with seven days of intravenous ceftriaxone for sepsis, the source of which was not clear. He made an uneventful recovery, and no carpapenamase-containing isolate was recovered from his stool at any other time. The $bla_{NDM-5}$ gene was carried on a partially assembled IncX3 plasmid. BLAST of this assembly against the NCBI database showed that this contig had 99% sequence identity with a previously sequenced pNDM-MGR194 46.2 kbp blaNDM-5 containing Inc-X3 plasmid found in India between 2011-13[@Krishnaraju2015]. We fully assembled the plasmid by mapping reads back to pNDM-MGR194 with Burrows-Wheeler alignment and found it to be extremely similar, with only 13 SNPs compared to pNDM-MGR194.

```{r wgs-amr-sum, echo = F, warning = F, message = F, fig.scap="Frequency distribution of AMR genes", out.extra='', fig.cap="A: Frequency distribution of AMR genes identified in isolates. Class of antimicrobial to which gene confers resistance is shown. B: Number of isolates with any mutation to a given class. Any mutation that could possibly confer resistance to a given class is included, including any mutation in the QRDR for quinolones. C: Phenotypic resistance patterns for subset of samples in this analysis that also underwent phenotypic testing (n = 449)", fig.height = 10, fig.width=8}

m.c <- read.csv(paste0(wd, "amr/srst2_pres_abs.csv"), stringsAsFactors = F)
m.c <- subset(m.c, name %in% tree$tip.label)

q.res <- read.csv(paste0(wd, "amr/qrdr_mut_presence.csv"), stringsAsFactors = F)
amr <- merge(m.c, q.res, by.x = "name", by.y = "sample")
amr.melt <- melt(amr) %>% subset(value > 0)

amr.melt$class <- NA
amr.melt$class[grepl("Par", amr.melt$variable) | 
                 grepl("Gyr", amr.melt$variable) | 
                 grepl("Par", amr.melt$variable) |
                 grepl("Qnr", amr.melt$variable) |
                 grepl("Qep", amr.melt$variable) |
                 grepl("Oqx", amr.melt$variable) |
                 grepl("Nor", amr.melt$variable)] <- "Quinolone"

amr.melt$class[grepl("Tet", amr.melt$variable) ] <- "Tetracyclines"

narrow_spec <- c("TEM_1", "TEM_95", "TEM_135", "TEM_90",
                 "OXA_1", 
                 "SHV_1")

amr.melt$class[amr.melt$variable %in% esbl] <- "ESBL"
amr.melt$class[amr.melt$variable %in% narrow_spec] <- "Penicillins"

amr.melt$class[grepl("Sul", amr.melt$variable) ] <- "Sulphonamides"

amr.melt$class[grepl("Str", amr.melt$variable) | 
                 grepl("Aad", amr.melt$variable) | 
                 grepl("Aac", amr.melt$variable) |
                 grepl("Aph", amr.melt$variable) |
                 grepl("Rmt", amr.melt$variable) |
                 grepl("APH", amr.melt$variable)] <- "Aminoglycosides"

amr.melt$class[grepl("Sat", amr.melt$variable) ] <- "Streptothricin"

amr.melt$class[grepl("LEN", amr.melt$variable) ] <- "Penicillins"
amr.melt$class[grepl("SCO", amr.melt$variable)  |
                grepl("BlaZ", amr.melt$variable) |
                 grepl("CARB", amr.melt$variable) |
                 grepl("PBP", amr.melt$variable) ] <- "Penicillins"

amr.melt$class[grepl("NDM", amr.melt$variable) ] <- "Carbapenems"

amr.melt <- subset(amr.melt, variable != "MrdA")
amr.melt <- subset(amr.melt, variable != "LAP_2")

amr.melt$class[grepl("Mph", amr.melt$variable) ] <- "Tetracyclines"
amr.melt$class[grepl("Mef", amr.melt$variable) |
                grepl("Erm", amr.melt$variable)  ] <- "Tetracyclines"

amr.melt$class[grepl("Fos", amr.melt$variable) ] <- "Fosfomycin"

amr.melt$class[grepl("Cat", amr.melt$variable) | 
                 grepl("FloR", amr.melt$variable) |
                 grepl("Cml", amr.melt$variable) ] <- "Chloramphenicol"

amr.melt$class[grepl("Dha", amr.melt$variable) | 
                 grepl("CMY", amr.melt$variable) ] <- "AmpC"

amr.melt$class[grepl("Dfr", amr.melt$variable) ] <- "Trimethoprim"


amr.melt$class[grepl("Arr", amr.melt$variable) ] <- "Rifampicin"

amr.melt <- subset(amr.melt, !(grepl("Amp", variable) | grepl("AMP", variable)))

classlevels <- amr.melt %>% group_by(variable, class) %>% summarise(n = n())

temp <- c("Penicillins", "ESBL", "AmpC", "Carbapenems")


classlevels$class <- factor(classlevels$class, levels = rev(c(temp, unique(amr.melt$class)[!(unique(amr.melt$class) %in% temp)])))

amr.melt$variable<- factor(amr.melt$variable, levels = classlevels$variable[order(classlevels$class, classlevels$n)])



col <- c(brewer.pal(8,"Dark2"),brewer.pal(8,"Dark2") )

data.frame((table(classlevels$class))) -> linebreaks
linebreaks$cumsum <- cumsum(linebreaks$Freq)

start <- list()
end <- list()
label <- list()

for (i in 1:nrow(linebreaks)) {
  if (i == 1) {
    start[[i]] <- 1
    end[[i]] <- linebreaks$cumsum[i]
    label[[i]] <- as.character(linebreaks$Var1[i])
  } else {
    start[[i]] <- linebreaks$cumsum[i-1] + 1
    end[[i]] <- linebreaks$cumsum[i]
    label[[i]] <- as.character(linebreaks$Var1[i])
  }
}

do.call(rbind, start) -> start
do.call(rbind, end) -> end
do.call(rbind, label) -> label

data.frame(start = start, end = end, label = label) -> pos

pos$text.y <- pos$start + (pos$end - pos$start)/2

pos$start == pos$end -> chflag

pos$start[chflag] <- pos$start[chflag] - 0.2
pos$end[chflag] <- pos$end[chflag] + 0.2


ggplot(amr.melt, aes(variable, fill = class)) + geom_bar()+ theme_bw() + theme(axis.text.y = element_text(size = 6), legend.position = "none", plot.margin = unit(c(0.2,0.2,0.2,3.5), "cm"), axis.title = element_blank() )   + coord_flip(ylim = c(-5,473),clip = "off", expand = FALSE) +  annotate(geom = "segment", x = pos$start, xend = pos$end, y = -100, yend = -100 )  + annotate(geom = "text", y = -110, x = pos$text.y, label = pos$label, size = 3, hjust = 1) -> p1

amr.class <- unique(select(amr.melt, name, class))
amr.class$class <- factor(amr.class$class, levels = rev(levels(classlevels$class)))

ggplot(amr.class, aes(class, fill = as.character(class))) + geom_bar() +theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5), legend.position = "none", axis.title = element_blank()) -> p2



# load phenotypic data

orgs <- read.csv("/Users/joelewis/Documents/PhD/Data/ESBL/ESBL_orgs.csv", stringsAsFactors = F)
orgs <- subset(orgs,profile_name == "DASSIM Culture")

orgs <- orgs[c(1,4,5:10)]

melt(orgs, id.vars = c('sample_number', 'organism')) -> orgs
subset(orgs, value != "") -> orgs
subset(orgs, organism == "Escherichia coli" ) -> orgs


#orgs$value <- factor(orgs$value, levels = c("Resistant", "Sensitive", "Intermediate" ))
orgs$variable <- map_chr(as.character(orgs$variable), function(x) strsplit(x , "\\.")[[1]][[1]])



sub("#","_", sample_ids$Lane) -> sample_ids$Lane
subset(sample_ids, Lane %in% tree$tip.label) -> sample_ids
orgs <- subset(orgs, sample_number %in% sample_ids$Supplier.Name)
orgsall <- orgs
subset(orgs, value != "Sensitive") -> orgs

rbind(orgs, 
      data.frame(sample_number = unique(orgs$sample_number),
                 organism = rep("Escherichia coli", base::length(unique(orgs$sample_number))),
                 variable = rep("ESBL", base::length(unique(orgs$sample_number))),
                 value = rep("Resistant", length(unique(orgs$sample_number)))
      )
      )-> orgs
                 
                                
cols <- hue_pal()(14)

orgs$variable <- factor(orgs$variable, 
                        levels = c("ESBL", "Meropenam", "Amikacin", "Gentamicin",
                                   "Chloramphenicol", "Cotrimoxazole", "Ciprofloxacin") )
ggplot(orgs, aes(variable, fill =variable)) + geom_bar() + theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), legend.position  = "none", axis.title = element_blank()) + 
  scale_fill_manual(values = cols[c(5,3,1,1,4,14,8)]) -> p3

ggarrange(p1, ggarrange(NULL,p2, p3,NULL, ncol = 1, nrow = 4, labels =c(NA,"B","C", NA), heights = c(0.5,1,1,0.5)), ncol = 2, nrow = 1, widths = c(1.5,1), labels = c("A", NA))

```

#### Quinolone resistance

108/473 (23%) of isolates contained plasmid-mediated quinolone resistance PMQR) genes, either $qnr$ or $qep$. Nonsynonymous mutations were identified in at least one of the quinolone resistance-determining regions (QRDR) - $gyrA$, $gyrB$, $parC$, or $parE$ - in 349/449 (78%) of isolates. The majority of mutations were well-described QRDR mutations (codon 83 and 87 in $gyrA$, codon 80 and 84 in $parC$ and codon 458 in $parE$, Figure \@ref(fig:wgs-amr-quin)A). QRDR mutations tended to cluster togather (Figure \@ref(fig:wgs-amr-quin)B) but alone they correlated poorly with phenotypic resistance. Of the 449 samples with available phenotypic sensitivity data, 294/449 (65%) were intermediate or resistant to ciprofloxacin, but 349/449 (78%) had a mutation in any codon in one of the four QRDR; presence of any QRDR mutation together with presence of PMQR had sensitivity of 95% (95% CI 93-98%) but specificity of 27% (95% CI 20-34%) for phenotypic quinolone resistance. Presence of mutations at all of codon 83 and 87 of $gyrA$ and at codon 80 of $parC$ has previously been shown to have the best predictive ability of phenotypic resistance[@Ostrer2019], and this showed improved, but still poor, discrimination for phenotypic resistance with sensitivity 89% (95% 85-93%) and specificity 54% (95% CI 46-62%) in this dataset.

```{r wgs-quin-setup, include = F}

read_tsv(paste0(wd, "amr/QRDR_ariba_output.tsv")) -> q.df




names(q.df)[length(names(q.df))] <- "sample"

subset(q.df, ref_name != "ref_name") -> q.df

sub("#", "_", q.df$sample) -> q.df$sample
subset(q.df, sample %in% tree$tip.label) -> q.df

select(q.df, sample, ref_name, ref_ctg_change) -> q.df

q.df$codon_posn <- str_sub(q.df$ref_ctg_change,2,-2)

q.df$wt_codon <-  str_sub(q.df$ref_ctg_change,1,1)

q.df$mut_codon <- str_sub(q.df$ref_ctg_change,-1,-1)

q.df$codon_posn <- as.numeric(q.df$codon_posn)

q.df <- subset(q.df, (ref_name == "GyrA" & codon_posn >= 67 & codon_posn <= 108) |
                 (ref_name == "GyrB" & codon_posn >= 331 & codon_posn <= 480) |
                (ref_name == "ParC" & codon_posn >= 38 & codon_posn <= 169) |
                (ref_name == "ParE" & codon_posn >= 365 & codon_posn <= 525) )

df.gyra <- subset(q.df, ref_name == "GyrA" & codon_posn >= 67 & codon_posn <= 108)

q.df %>% dplyr::group_by(ref_name, codon_posn) %>% dplyr::summarise(n=n()) -> df.sum

df.gyra <- subset(df.sum, ref_name == "GyrA" & codon_posn >= 67 & codon_posn <= 108)
df.gyrb <- subset(df.sum, ref_name == "GyrB" & codon_posn >= 331 & codon_posn <= 480)
df.parc <- subset(df.sum, ref_name == "ParC" & codon_posn >= 38 & codon_posn <= 169)
df.pare <- subset(df.sum, ref_name == "ParE" & codon_posn >= 365 & codon_posn <= 525)


ggplot(df.gyra, aes(x= codon_posn, y = n)) + geom_point()  + xlim(c(67,108)) +
  theme_bw() + ylim(c(0,400)) + ggtitle("GyrA") + xlab("Codon position")-> p1
  
ggplot(df.gyrb, aes(x= codon_posn, y = n)) + geom_point()  + xlim(c(331,480)) +
  theme_bw() + ylim(c(0,400)) + ggtitle("GyrB")  + xlab("Codon position") -> p2
     
ggplot(df.parc, aes(x= codon_posn, y = n)) + geom_point()  + xlim(c(38,169)) +
  theme_bw() + ylim(c(0,400)) + ggtitle("ParC")  + xlab("Codon position")-> p3

ggplot(df.pare, aes(x= codon_posn, y = n)) + geom_point()  + xlim(c(365,525)) +
  theme_bw()  + ylim(c(0,400)) + ggtitle("ParE") + xlab("Codon position") -> p4



orgs.cip <- subset(orgsall, variable == "Ciprofloxacin")

orgs.cip <- merge( select(sample_ids, Supplier.Name, Lane),select(orgs.cip,sample_number, value),   by.x = "Supplier.Name", by.y = "sample_number")

orgs.cip <- merge(orgs.cip, q.res, by.x = "Lane", by.y = "sample")

q.df$key <- paste0(q.df$ref_name, q.df$codon_posn)

q.df.new <- subset(q.df, key == "GyrA83" |  key == "GyrA87" | key == "ParC80" | key == "ParE458")

dcast(q.df.new,sample ~ key, fun.aggregate = base::length) -> q.df.new

orgs.cip <- merge(orgs.cip, q.df.new, by.x = "Lane", by.y = "sample", all.x = T)
orgs.cip[is.na(orgs.cip)] <- 0
orgs.cip$value[orgs.cip$value == "Resistant" |orgs.cip$value == "Intermediate" ] <- 1
orgs.cip$value[orgs.cip$value == "Sensitive" ] <- 0
orgs.cip$value <- as.numeric(orgs.cip$value)

pmqr <- m.c[ c("name", grep("Qnr", names(m.c), value = T) , grep("Qep", names(m.c), value = T) )]

pmqr$Qnr <- apply(pmqr[grep("Qnr", names(pmqr), value = TRUE )], 1, sum)
pmqr$Qep <- apply(pmqr[grep("Qep", names(pmqr), value = TRUE )], 1, sum)

pmqr$Qnr[pmqr$Qnr > 1] <- 1
pmqr$Qep[pmqr$Qep > 1] <- 1

orgs.cip <- merge(orgs.cip, select(pmqr, name, Qnr, Qep), by.x = "Lane", by.y = "name")
names(orgs.cip)[names(orgs.cip) == "value"] <- "Quinolone resistance"

orgs.cip$gyra.parc.and.plasm <-(orgs.cip$GyrA83 & orgs.cip$GyrA87 & orgs.cip$ParC80) | orgs.cip$Qnr | orgs.cip$Qep

orgs.cip$gyra.parc.or.plasm <-(orgs.cip$GyrA83 | orgs.cip$GyrA87 | orgs.cip$ParC80) | orgs.cip$Qnr | orgs.cip$Qep

orgs.cip %>% summarise(TP = sum(`Quinolone resistance` == 1 & gyra.parc.and.plasm == TRUE),
                       FP = sum(`Quinolone resistance` == 0 & gyra.parc.and.plasm == TRUE),
                       TN = sum(`Quinolone resistance` == 0 & gyra.parc.and.plasm == FALSE),
                       FN = sum(`Quinolone resistance` == 1 & gyra.parc.and.plasm == FALSE)) -> summ

#binom.test(summ$TP, (summ$TP + summ$FN))
#binom.test(summ$TN, (summ$TN + summ$FP))

orgs.cip %>% summarise(TP = sum(`Quinolone resistance` == 1 & gyra.parc.or.plasm == TRUE),
                       FP = sum(`Quinolone resistance` == 0 & gyra.parc.or.plasm == TRUE),
                       TN = sum(`Quinolone resistance` == 0 & gyra.parc.or.plasm == FALSE),
                       FN = sum(`Quinolone resistance` == 1 & gyra.parc.or.plasm == FALSE)) -> summ2

#binom.test(summ2$TP, (summ2$TP + summ2$FN))
#binom.test(summ2$TN, (summ2$TN + summ2$FP))

orgs.cip <- orgs.cip[order(orgs.cip$`Quinolone resistance`, orgs.cip$GyrA83, orgs.cip$GyrA87, orgs.cip$ParC80, orgs.cip$ParE458, orgs.cip$Qnr, orgs.cip$Qep),]

names(orgs.cip)[names(orgs.cip) == "Quinolone resistance"] <- "CIP resistance"
#dev.off()
grid.grabExpr(pheatmap(orgs.cip[c(3,8,9,10,11,12,13)], cluster_cols = FALSE, cluster_rows = FALSE, show_rownames = FALSE,
                       legend = FALSE)) -> hm
hm <- as_ggplot(hm)
#dev.off()

ggarrange(ggarrange(p1,p2,p3,p4, ncol =2, nrow =2), NULL, hm,NULL, ncol = 4, nrow = 1, labels = c("A", "B",NA,NA), widths = c(1,0.2,0.6,0.2)) -> parrange

ggsave(paste0(wd,"quinolone_plot.pdf"), plot = parrange, width = 18, height = 8, units = "cm")

```

```{r wgs-amr-quin, echo = F, warning = F, message = F, fig.scap="Quinolone resistance mutations and phenotypic resistance", out.extra='', fig.cap="A: Mutation positions in quinolone resistance-determining regions, showing that most mutations are well-recognised (see text for details) B: Co-occurance heatmap of QRDR mutations (\\textit{gyrA}, \\textit{parC}, or \\textit{parE}) plamid-mediated quinolone resistance mutations (\\textit{qnr} or \\textit{qep}) and phenotypic resistance. Each row is one sample, red = presence, blue = absence."}

knitr::include_graphics(paste0(wd,"quinolone_plot.pdf"))
```

#### Aminoglycoside resistance

Aminoglycoside resistance genes were very common in the sequenced isolates, with 469/473 (99%) of isolates containing at least one aminoglycoside gene, and most containing multiple different genes: median number of aminoglycoside resistance genes per isolate was 4 (IQR 3-5). Despite streptomycin being absent from all Malawian treatment guidelines save for retreatment of tuberculosis, the streptomycin resistance genes $strA$, $strB$ and $aadA$ family of genes (also called _aad(3")_) were very commonly seen (Figure \@ref(fig:wgs-amr-aminogly)A). Genes that would be expected to confer gentamicin resistance - _aac(3)-IIa_, _aac(3)-IId_ and _aac(6')-Ib-cr_ were common, but genes that would be expected to confer amikacin resistance (_rmtB_) and kanamycin resistance (_aph(3')_) were unusual (Figure \@ref(fig:wgs-amr-aminogly)B)[@Ramirez2010; @Galimand2003] 

The predictive value of presence of _aac(3)-IIa_, _aac(3)-IId_ or _aac(6')-Ib-cr_ for phenotypic gentamicin resistance was moderate at best with sensitivity 77% (95% CI 71-83%) and specificity 73% (95% CI 67-79%). Of 6 phenotypically amikacin resistant or intermediate isolates, all had recognised streptomycin resistance determinents (_strA_, _strB_ or _aadA_) but 4/6 had no other aminoglycoside determinent identified. Of the remaining two, one isolate contained _aac(6')-Ib-cr_ and one both _aac(3)-IIa_, _aac(3)-IId_. 

```{r wgs-amr-aminogly-setup, include = F}

amr.melt %>% filter(class == "Aminoglycosides") %>% group_by(variable) %>% summarise(n= n()) -> ag

ag$agent <- NA 
ag$agent[grepl("Str", ag$variable) | grepl("AadA", ag$variable)] <- "Streptomycin"

ag$agent[grepl("Aac6", ag$variable) | grepl("Aac3_II", ag$variable)] <- "Gentamicin"

ag$agent[grepl("Aph", ag$variable)] <- "Kanamycin"
ag$agent[grepl("Rmt", ag$variable)] <- "Amikacin"

ag$agent <- factor(ag$agent, levels = c("Streptomycin", "Gentamicin", "Amikacin","Kanamycin"))

ag$variable <- factor(ag$variable, levels = (ag$variable[order(ag$agent, ag$n)]))

orgsall %>% filter(variable == "Amikacin" | variable == "Gentamicin") %>% dcast(sample_number ~ variable, value.var = "value") -> ag.sens

ag.sens <- merge(select(sample_ids, Supplier.Name, Lane), ag.sens, by.x = "Supplier.Name", by.y = "sample_number")

ag.genes <- m.c[c("name", names(m.c)[names(m.c) %in% ag$variable])]

ag.genes$Aac_II <- apply(m.c[grep("Aac3_II", names(m.c), value = TRUE)], 1 , sum)

ag.genes$Aac_II[ag.genes$Aac_II > 1] <- 1 
ag.genes$AadA <- apply(m.c[grep("AadA", names(m.c), value = TRUE)], 1 , sum)

ag.genes$AadA[ag.genes$AadA > 1] <- 1 

ag.genes$Str <- apply(m.c[grep("StrA", names(m.c), value = TRUE)], 1 , sum)
ag.genes$Str[ag.genes$Str > 1] <- 1 

ag.genes$Aph3_sum <- apply(m.c[grep("Aph3", names(m.c), value = TRUE)], 1 , sum)
ag.genes$Aph3_sum[ag.genes$Aph3_sum > 1] <- 1 

ag.genes <- ag.genes[c(1,4,17,14, 20)]

ag.sens <- merge(ag.sens, ag.genes, by.x = "Lane", by.y= "name", all.x = T)

ag.sens$Amikacin[ag.sens$Amikacin == "Sensitive"] <- 0
ag.sens$Amikacin[ag.sens$Amikacin == "Resistant" | ag.sens$Amikacin =="Intermediate"] <- 1

ag.sens$Gentamicin [ag.sens$Gentamicin== "Sensitive"] <- 0
ag.sens$Gentamicin[ag.sens$Gentamicin == "Resistant" | ag.sens$Gentamicin =="Intermediate"] <- 1

ag.sens$Amikacin <- as.numeric(ag.sens$Amikacin)
ag.sens$Gentamicin <- as.numeric(ag.sens$Gentamicin)

ag.sens[order(ag.sens$Amikacin, ag.sens$Gentamicin, ag.sens$Aac_II, ag.sens$Aac6Ib_cr),] -> ag.sens 
names(ag.sens)[c(3,4,8)] <- c("Amikacin resistance", "Gentamicin resistance", "Ap3")


ag.sens %>% summarise(TP = sum(`Gentamicin resistance` == 1 & (Aac6Ib_cr == 1 | Aac_II == 1)),
                       FP = sum(`Gentamicin resistance` == 0 & (Aac6Ib_cr == 1 | Aac_II == 1)),
                       TN = sum(`Gentamicin resistance` == 0 & (Aac6Ib_cr == 0 & Aac_II == 0)),
                       FN = sum(`Gentamicin resistance` == 1 & (Aac6Ib_cr == 0 & Aac_II == 0))) -> summ

names(ag.sens)[c(3,4,8)] <- c("AMK resistance", "GEN resistance", "Ap3")

ggplot(ag, aes(x= variable, y =n , fill = agent)) + geom_col() + theme_bw() + theme(axis.text.x = element_text(angle = -90), legend.title = element_blank(), legend.position = "bottom") + labs(x= "Aminoglycoside resistance gene") -> p1
grid.grabExpr( pheatmap(ag.sens[c(3,4,6,5,7,8)], cluster_cols = F, cluster_rows = F, legend = F, show_rownames = F)) -> hm
hm <- as_ggplot(hm)



 #sens
#binom.test(summ$TP, (summ$TP + summ$FN))
# spec
#binom.test(summ$TN, (summ$TN + summ$FP))
ggarrange(p1, NULL,hm,NULL, ncol= 4, nrow = 1, widths = c(1,0.2,0.6,0.2), labels  = c("A", "B", NA, NA)) -> parrange

ggsave(paste0(wd,"aminoglycoside_plot.pdf"), plot = parrange, width = 20, height = 8, units = "cm")

```

```{r wgs-amr-aminogly, echo = F, warning = F, message = F, fig.scap="Aminoglycoside resistance mutations and phenotypic resistance", out.extra='', fig.cap="A: Aminoglycoside mutations and expected resistance to gentamicin, amikacin and kanamycin B: Heatmap showning phenotypic amikacin and gentamicin resistance and identified resistance genes that could be expected to confer resistance to these agents (see text for details). Aac\\_II in heatmap indicates presence of either \\textit{aac(3)-IIa} or\\textit{aac(3)-IIa} gene. Each row is one sample, red = presence, blue = absence."}

knitr::include_graphics(paste0(wd,"aminoglycoside_plot.pdf"))
```

#### Chloramphenicol, co-trimoxazole, tetracycline and other resistance determinents

248/473 (52%) of isolates contained at least one chloramphenicol resistance gene (Figure \@ref(fig:wgs-amr-sum)), usually 1 (210/248 [85%]), less commonly 2 (37/248 [15%]) or 3 (1/248 [<1%]). _catB4_ was the most commonly identified gene but once again phenotypic chloramphenicol resistance correlated poorly with presence of chloramphenicol resistnce genes (\@ref(fig:wgs-amr-chlor-cotrim)A)) with presence of any chloramphenicol resistance gene predicting phenotypic resistance with a sensitivity of 70% (95% 62-78%) and specificity of 55% (95% CI 49-60%).

Almost all isolates contained either a trimethoprim resistance (459/473 [97%]) or a sulphonamide resistance gene (468/473 [99%]); only 3/473 isolates did not contain either. Trimethoprim resistance genes were all of the _dfrA_ family; _sulII_ was the commonest sulphonamide resistance determinent (Figures \@ref(fig:wgs-amr-sum) and \@ref(fig:wgs-amr-chlor-cotrim)B). Summary sensitivity of presence of any _dfrA_ or _sul_ gene as a predictor of phenotypic resistance was 100% [95% CI 99- 100%] but (partially due to the rarity of cotrimoxazole sensitivity in this datset) specificity was 13% [95% CI 2-40%].

Tetracycline resistance genes were also very common, identified in 422/473 (89%) of isolates, most commonly _mphA_ (324/473 [68%] of isolates), followed by _tetB_ (262/473 [55%] of isolates) and _tetA_ (193/473 [41%] of isolates). No antimicrobial sensitivity testing was carried out for any agent of the tetracycline class. Resistance determinents for rifampicin (_arr2_ and _arr3_) were rarely identified, in 2 isolates and the _sat2_ gene, conferrning resistance to streptothricin (a nucleoside antibiotic with no clinical compounds in use) was seen in 69/473 [15%] of isolates; the significance of this is unknown. Finally, the fosfomycin resistance determinent _fosA_ was seen in 28/473 [6%] of isolates, despite this antimicrobial being unavailable in Malawi.

```{r wgs-amr-chlor-cotrim-setup, include= FALSE}


amr.melt %>% filter(class == "Chloramphenicol") %>% group_by(variable) %>% summarise(n= n()) -> cl
orgsall %>% filter(variable == "Chloramphenicol") %>% dcast(sample_number ~ variable, value.var = "value") -> cl.sens
cl.sens <- merge(select(sample_ids, Supplier.Name, Lane), cl.sens, by.x = "Supplier.Name", by.y = "sample_number")
cl.genes <- m.c[c("name", names(m.c)[names(m.c) %in% cl$variable])]
cl.sens <- merge(cl.sens, cl.genes, by.x = "Lane", by.y= "name", all.x = T)
cl.sens$Chloramphenicol[cl.sens$Chloramphenicol == "Sensitive"] <- 0
cl.sens$Chloramphenicol[cl.sens$Chloramphenicol == "Resistant" | cl.sens$Chloramphenicol =="Intermediate"] <- 1
cl.sens$Chloramphenicol <- as.numeric(cl.sens$Chloramphenicol)
names(cl.sens)[names(cl.sens) == "Chloramphenicol"] <- "CHL resistance"

cl.sens <- cl.sens[order(cl.sens$`CHL resistance`, cl.sens$CatB4, cl.sens$CatA1, cl.sens$CmlA1, cl.sens$CatB3),]
grid.grabExpr( pheatmap(cl.sens[c(3,8,5,9,7,6,4,10)], cluster_cols = F,cluster_rows = F, legend = F, show_rownames = F)) -> hm1
hm1<- as_ggplot(hm1)

amr.melt %>% filter(class == "Trimethoprim" | class == "Sulphonamides") %>% group_by(variable) %>% summarise(n= n()) -> cot

orgsall %>% filter(variable == "Cotrimoxazole") %>% dcast(sample_number ~ variable, value.var = "value") -> cot.sens
cot.sens <- merge(select(sample_ids, Supplier.Name, Lane), cot.sens, by.x = "Supplier.Name", by.y = "sample_number")
cot.genes <- m.c[c("name", names(m.c)[names(m.c) %in% cot$variable])]
cot.sens <- merge(cot.sens, cot.genes, by.x = "Lane", by.y= "name", all.x = T)
cot.sens$Cotrimoxazole[cot.sens$Cotrimoxazole == "Sensitive"] <- 0
cot.sens$Cotrimoxazole[cot.sens$Cotrimoxazole == "Resistant" | cot.sens$Cotrimoxazole =="Intermediate"] <- 1
cot.sens$Cotrimoxazole <- as.numeric(cot.sens$Cotrimoxazole)

cot.sens$DfrA <- apply(cot.sens[grep("DfrA", names(cot.sens), value = T)], 1, sum)
cot.sens$DfrA[cot.sens$DfrA > 1] <- 1

cot.sens <- cot.sens[order(cot.sens$Cotrimoxazole, cot.sens$DfrA, cot.sens$SulIII, cot.sens$SulI, cot.sens$SulII),]

names(cot.sens)[names(cot.sens) == "Cotrimoxazole"] <- "Cotrimoxazole resistance"

cot.sens$any_gene <- apply(cot.sens[c(17,15,14,16)], 1, sum)
cot.sens$any_gene[cot.sens$any_gene >1 ] <- 1
cot.sens %>% summarise(TP = sum(`Cotrimoxazole resistance` == 1 & any_gene == 1),
                       FP = sum(`Cotrimoxazole resistance` == 0 & any_gene == 1),
                       TN = sum(`Cotrimoxazole resistance` == 0 & any_gene == 0),
                       FN = sum(`Cotrimoxazole resistance` == 1 & any_gene == 0)) -> summ

names(cot.sens)[names(cot.sens) == "Cotrimoxazole resistance"] <- "SXT resistance"

grid.grabExpr( pheatmap(cot.sens[c(3,17,15,14,16)], cluster_cols = F, cluster_rows = F,legend = F, show_rownames = F)) -> hm2
hm2<- as_ggplot(hm2)




 #sens
#binom.test(summ$TP, (summ$TP + summ$FN))
# spec
#binom.test(summ$TN, (summ$TN + summ$FP))

ggarrange(NULL,hm1,NULL,hm2,NULL, ncol = 5, nrow = 1, labels = c("A",NA,"B",NA,NA), widths = c(0.2,0.6,0.2,0.6,0.2)) -> parrange

ggsave(paste0(wd,"chor_cotrim_plot.pdf"), plot = parrange, width = 20, height = 8, units = "cm")
```

```{r wgs-amr-chlor-cotrim, echo = F, warning = F, message = F, fig.scap="Chloramphenicol and cotrimoxazole resistance mutations and phenotypic resistance", out.extra='', fig.cap="Heatmap showning phenotypic chloramphenicol (A) and cotrimoxazole (B) resistance and identified resistance genes that could be expected to confer resistance to these agents. Each row is one sample, red = presence, blue = absence"}

knitr::include_graphics(paste0(wd,"chor_cotrim_plot.pdf"))

```

#### Clustering and lineage association of AMR determinents

Next, I explored associations of AMR determinents, both with each other in an attempt to identify putative clusters that could represent mobile genetic elements (MGE) that could be tracked within and between patients, and with lineages of the phylogeny. There was clear clustering of AMR genes beyond what would be expected by chance (Figures \@ref(fig:wgs-amr-cooccur-plot)A and B), including clustering of the ESBL gene $bla_{CTX-M-15}$ with penicillinases $bla_{OXA-1}$ and $bla_{TEM-95}$. Though some identified clusters correspond to known MGE (e.g. the _sulII-strA-strB_ cluster[@Anantham2012]), there was a clear lineage association of certain gene combinations on mapping the presence or absence of AMR determinents back to the phylogeny (Figure \@ref(wgs-amr-cooccur-plot)C), meaning that these AMR-gene associations likely represent a combination of colocation on MGE and confounding by association with lineage. 

```{r wgs-amr-maptotree,include = F}
tree <- read.tree(paste0(wd, "core_genome_tree/core_alnD2ESCO_snp_sites.aln.treefile"))
midpoint.root(tree) -> tree
plasm <- read.csv(paste0(wd, "amr/plasm_Inc_pres_abs.csv"), stringsAsFactors = F)
m.c <- read.csv(paste0(wd, "amr/srst2_pres_abs.csv"), stringsAsFactors = F)
m.c <- subset(m.c, name %in% tree$tip.label)
qr <- read.csv(paste0(wd, "amr/qrdr_mut_presence.csv"), stringsAsFactors = F)
rownames(qr) <- qr$sample
rownames(m.c) <- m.c$name
rownames(plasm) <- plasm$name

sapply(m.c[,-1], as.character) -> m.c[2:ncol(m.c)]
sapply(qr[,-1], as.character) -> qr[2:ncol(qr)]
sapply(plasm[,-1], as.character) -> plasm[2:ncol(plasm)]
qr[qr == "1"] <- "3"
plasm[plasm == "1"] <- "2"
hm <- merge(qr, m.c, by.x = "sample", by.y = "name")
hm <- merge(hm, plasm, by.x = "sample", by.y = "name")
hm <- subset(hm, sample %in% tree$tip.label)
# get rid of 0 cols
apply(sapply(hm[-1], as.numeric),2, sum) -> sums
hm <- hm[c("sample", names(sums[sums != 0]))]
hm <- select(hm, -AmpC1, -AmpC2, -AMPH, -MrdA)
rownames(hm) <- hm$sample
ggtree(tree) %>% gheatmap(hm[,-1], font.size = 2,
colnames_position = "top", colnames_angle = 90, colnames_offset_y = 20,
color = NA, width = 3, offset = 0.02)  + scale_fill_manual(values = c("white", cols[1],cols[12], cols[8])) +
  theme(legend.position = "none") -> p3
```


```{r wgs-amr-jaccmat, include = F}

jcoefs <- read.csv(paste0(wd, "amr/amr_jaccard_matrix.csv"), stringsAsFactors = F, row.names = 1)

#jpvals <- read.csv("/Users/joelewis/Documents/Sanger/final_analysis/all_DASSIM_esco/ariba #amr/cleaned/amr_jaccard_pvals.csv", stringsAsFactors = F, row.names = 1)


 grid.grabExpr( pheatmap(jcoefs, fontsize = 5, color = viridis(n = 100, option = "plasma"), border_color = NA) ) ->p2
p2 <- as_ggplot(p2)

```

```{r wgs-amr-cooccurnet, include = F}

jcoefs <- select(jcoefs, -AmpC1, -AmpC2, -AMPH, -MrdA)
jcoefs[!(rownames(jcoefs) %in% c("AmpC1", "AmpC2", "AMPH", "Mrd")),] -> jcoefs

jpvals <- read.csv(paste0(wd, "amr/amr_jaccard_pvals.csv"), stringsAsFactors = F, row.names = 1)
jpvals <- select(jpvals, -AmpC1, -AmpC2, -AMPH, -MrdA)
jpvals[!(rownames(jpvals) %in% c("AmpC1", "AmpC2", "AMPH", "Mrd")),] -> jpvals
jpvals$gene <- rownames(jpvals)
melt(jpvals, id.vars = "gene") -> jpvals_long
names(jpvals_long) <- c("gene1", "gene2", "pval")
jcoefs$gene <- rownames(jcoefs)
melt(jcoefs, id.vars = "gene") -> jcoefs_long
names(jcoefs_long) <- c("gene1", "gene2", "jacc")
jtots <- merge(jcoefs_long, jpvals_long, by = c("gene1", "gene2"))
jpvals_sig <- subset(jpvals_long, pval < 0.05/nrow(jpvals_long))

# ok lets make a graph of these

jtots2 <- subset(jtots, jacc > 0.5 & pval < 0.05/nrow(jpvals_long))
apply(select(jpvals_sig, gene1, gene2), 1, 
      function(x) paste(sort(x), collapse = "")) -> jpvals_sig$key
subset(jpvals_sig, !duplicated(key)) -> jpvals_sig_unique
g1 <- graph_from_data_frame(jtots[1:3], directed = F)
g2 <- graph_from_data_frame(jtots2[1:3], directed = F)
n_genes <- apply(sapply(all[-1], as.numeric), 2, sum)


g2 %>%
  ggraph(layout="kk") +
  geom_edge_link(colour = "grey", alpha = 0.7) + geom_node_point(aes(size = (n_genes[V(g2)$name])), colour = viridis::plasma(100)[50], alpha = 0.8) +
  geom_node_text(aes(label = name), size = 4, repel = T) +
  theme_graph(foreground=NA) + theme(legend.position = "none") -> p1
 

```

```{r wgs-amr-cooccur-plot, echo = F, warning = F, message = F, fig.scap="Co-occurance and lineage asociation of AMR genes", out.extra='', fig.cap="A:  Row and column clustered heatmap of pairwise Jaccard index matrix, showing clustering of AMR genes. B: Networks of commonly (jaccard index > 0.5) and significantly (p < 0.05, Bonferroni corrected) co-occuring AMR genes. C: AMR genes mapped back to midpoint rooted maximum likelihood phylogenetic tree, showing lineage associations of genes.", fig.width = 11, fig.height = 14}

ggarrange(ggarrange(p2,
                    ggarrange(NULL,p1,NULL, heights = c(0.1,1,0.1), ncol = 1, nrow =3, labels = c("B", NA,NA)),
                    nrow =1, ncol= 2, widths = c(1.2,0.8), labels = c("A", NA)), 
          p3, ncol = 1, nrow = 2, labels = c(NA, "C"), heights = c(0.8,1))

```

### Plasmid replicons

Presence or absence of the identified plasmid repicons is shown mapped to the phylogeny in Figure \@ref(fig:wgs-amr-cooccur-plot)C. IncFIb was most commonly identified (399/473 [84%] of isolates), followed by IncFII (383/473 [81%] of isolates) and IncF1a (324/373 [68%] of isolates). Col plasmids were also frequently identified, in 308/473 [65%] of isolates. Once again, there seems to be some lineage associations of presence or absence of replicons.

### Testing metadata associations: SNP distance, hierBAPS sequence clusters and ESBL-clusters

Finally, in order to test metadata associations of bacterial lineages or MGE, I used several techniques: considering core gene SNP distance between isolates to infer continous carriage and/or transmission events, and clustering core gene pseudosequences and ESBL-containing contigs into mutually exclusive groups which can then be used to test associations. Below, I first describe the outcomes of the clustering algorithms used, before decribing tests of association with metadata. 

#### Hierachichal BAPS clustering of core gene pseudosequences

The hieraechical BAPS algorithm clustered the core gene alignments into 15 level one (top level) clusters, denoted sequence clusters A-O, and a total of 48 level two (lower level) clusters, denoted sequence clusters 1-48 that were almost exclusivley monophyletic and often corresponded closely to the multilocus sequence types (STs, Figure \@ref(fig:wgs-hierbaps-plot-tree)A). Intracluster pairwise SNP distance varied (Figure \@ref(fig:wgs-hierbaps-plot-tree)B) but the clusters were often reasonably clonal: SC6, SC8 and SC23, for example (the three largest clusters) had median (IQR) intragroup pairwise SNP distance of 62 (34-97), 326 (18-378) and 18 (11-24) respectively.

```{r wgs-hierbaps-plot-tree, echo = F, warning = F, message = F, fig.scap="Core gene hierBAPS clusters", out.extra='', fig.cap="A: Core gene hierarchical BAPS clusters mapped back to phylogeny. Heatmap shows level 2 (lower level) with colour denoting level 1 (top level) cluster membership. B: Intracluster pairwise SNP distance for level 2 sequence clusters. Axis restricted to 0-1500 SNPs and as result SC17 (median 6881 SNPs), SC29 (median 2970 SNPs), SC31 (median 2970 SNPs) and SC44 (median 12322 SNPs) boxes are not shown. Boxplots show median and IQR, whiskers show 1.5 times IQR, and outliers are points falling beyond whiskers.", fig.width = 6, fig.height = 6}

readRDS(paste0(wd, "hierbaps/D2ESCO_core_snp_hbaps_clusts.rda")) -> hb.results

hbdf <- hb.results$partition.df
sub("_1#", "_1_",hbdf$Isolate) -> hbdf$Isolate
sub("_2#", "_2_",hbdf$Isolate) -> hbdf$Isolate

rownames(hbdf) <- hbdf$Isolate
names(hbdf)[2:3] <- c("BAPS.l1", "BAPS.l2")

hbdf$BAPS.l1 <- as.factor(hbdf$BAPS.l1)
hbdf$BAPS.l1 <- LETTERS[hbdf$BAPS.l1]
hbdf$BAPS.l2 <- as.factor(hbdf$BAPS.l2)

dcast(hbdf, Isolate ~ BAPS.l2, value.var = "BAPS.l1") -> hbdf.cast
hbdf %>% group_by(BAPS.l2) %>% summarise(n = n()) -> BAPSl2.freq

hbdf.cast[c("Isolate", as.character(BAPSl2.freq$BAPS.l2[order(BAPSl2.freq$n, decreasing = T)])) ] -> hbdf.cast

rownames(hbdf.cast) <- hbdf.cast$Isolate
sapply(hbdf.cast[2:ncol(hbdf.cast)], as.factor) -> hbdf.cast[2:ncol(hbdf.cast)]
hbdf.cast[is.na(hbdf.cast)] <- "Z"

cols2 <- c(brewer.pal(n=5, "Dark2"), brewer.pal(n=10, "Set3") , "lightgrey")
names(cols2) <- c(LETTERS[1:15], "Z")

ggtree(tree) %>% gheatmap(select(hbdf.cast, -Isolate), width = 3, 
                          colnames_position = "top", font.size = 2, colnames_angle = 90,
                          color = NA, colnames_offset_y = 10) +
  scale_fill_manual(breaks = LETTERS[1:15], values = cols2) + annotate("text", x= 0.4, y =510, label = "HierBAPS level 2 cluster") -> tr


## 


read_csv (paste0(wd, "core genome snp dist/snp-sites-snp-dist.csv") ) -> snp.dists

names(snp.dists)[1] <- "lane"
snpdists.df <- melt(snp.dists)
names(snpdists.df)[1:2] <- c("Var1", "Var2") 

snpdists.df$Var1 <- sub("_1#", "_1_", snpdists.df$Var1)
snpdists.df$Var1 <- sub("_2#", "_2_", snpdists.df$Var1)
snpdists.df$Var2 <- sub("_1#", "_1_", snpdists.df$Var2)
snpdists.df$Var2 <- sub("_2#", "_2_", snpdists.df$Var2)
snpdists.df$key <- apply(snpdists.df[1:2], 1, function(x)paste(sort(x), collapse='')) 
subset(snpdists.df, !duplicated(snpdists.df$key))  -> snpdists.df
subset(snpdists.df, Var1 != Var2) -> snpdists.df

snpdists.df <- select(snpdists.df, -key) 

merge(snpdists.df, hbdf, by.x = "Var1", by.y = "Isolate", all.x = T) -> snpdists.df
names(snpdists.df)[c(4,5)] <- c("BAPS.l1.1", "BAPS.l2.1")

merge(snpdists.df, hbdf, by.x = "Var2", by.y = "Isolate", all.x = T) -> snpdists.df
names(snpdists.df)[c(6,7)] <- c("BAPS.l1.2", "BAPS.l2.2")

within_l2_snpdist.df <- subset(snpdists.df, (BAPS.l2.1 == BAPS.l2.2))


ggplot(within_l2_snpdist.df, aes(x= fct_infreq(BAPS.l2.1), y = value)) + 
  geom_boxplot(alpha = 0.5, outlier.size = 0.1) + coord_cartesian(ylim = c(0,1500)) + theme_bw() + xlab("HierBAPS level 2 cluster") + ylab("No. SNPs")  + theme(axis.text.x = element_text(size = 6))  -> bp

# geom_jitter(alpha = 0.3, size = 0.1) + 
ggarrange(tr, NULL, bp, ncol = 1, nrow = 3, labels = c("A", "B", NA), heights = c(2,0.1, 0.8))
```

#### ESBL-clusters

The 473 samples contained 486 ESBL genes (Figure \@ref(fig:wgs-contig-map-to-tree)A); 5 genes only occured once in the collection and so no attempt was made to cluster them. Of the remaining 481 genes pairs, BLAST failed to identify the ESBL-gene containing contig in 2 samples (one in which _ARIBA_ had identified $bla-{ctxm15}$ one $bla_{ctxm27}$), but identified the remaining 479 ESBL genes on 478 contigs, with perfect agreement with _ARIBA_ as to which AMR gene was present in which sample. Only one contig carried two ESBL genes: $bla_{ctxm3}$ and $bla_{ctxm15}$; the remaining 477 contigs contained one. The _cd-hit_ algorithm grouped the 477 unique contigs into 99 clusters (Figure \@ref(fig:wgs-contig-map-to-tree)B). In total, over 90% of the ESBL-genes (432/479 [90%]) were contained in the 52 largest contig clusters.

The _cd-hit_ algorithm selects one member of a cluster (the longest) as the representative. The structure of these representative contigs was explored in an attempt to understand type of MGE they were likely to represent. The length of the reprentative clusters was very variable, ranging from 1.8kbp to 905.8kbp, with median (IQR) 46.1kbp (11.1-215.5kbp). The other cluster members were usually fragments of these representative contigs with varying sizes - a median (IQR) 60% (36-100%) of the representative contig length - but had high sequence identity, median (IQR) 100.0% (99.7-100.0%) (Figure \@ref(fig:wgs-contig-stats-plot) in the appendix to this chapter).

I then explored the insertion sequence (IS), AMR gene and plasmid replicon content of the representative contig for each cluster using BLAST against the SRST2, ISfinder and Plasmidfinder databases (Figures  \@ref(fig:wgs-contig-ggenes-plot1) and \@ref(fig:wgs-contig-ggenes-plot2) in the appendix to this chapter). Every ESBL gene was closely asssociates with at least one IS, commonly ISEcp1, IS26 and IS903B. IS26 was frequently associated with an apparent 108bp frangment of a _catB4_ chloramphenicol resistance determinent. Some ESBL-genes were associated with particular IS; $bla_{CTXM15}$, $bla_{CTXM9}$ and $bla_{CTXM1}$, for example were very commonly associated with ISEcp1, wheras $bla_{SHV12}$ was associated with IS26. ESBL genes were not infrequently associated with other resistance determinents, including commonly $bla_{CTXM15}$ with $bla_{TEM95}$. Plasmid replicons were occasionaly identified, including an IncFIB plasmid carrying $bla_{CTXM15}$ and an IncQ1 plasmid carrying $bla_{CTXM27}$. It is clear that the same configuration of AMR genes and IS are seen across different contigs, despite a varying backbone, implying historical transposition events. Finally, to assess lineage associations of the identified ESBL-clusters, I mapped the clusters back to the tree, and found that there was a strong lineage association (Figure \@ref(fig:wgs-contig-map-to-tree)C).

```{r wgs-conig-setup, echo = F, warning = F, message = F}


fileses <- list.files(paste0(wd, "contig_cluster/results"))
fileses <- grep(".clstr", fileses, value = T)

out <- list()
for (i in 1:length(fileses)) {
  #strsplit(fileses[[i]], "\\.")[1][[1]][[1]]
  #print(gene)
  outtemp <- parse_cd_hit_est_output_to_df(
    paste0(wd,"contig_cluster/results/",fileses[i])) 
  outtemp$gene <- strsplit(fileses[[i]], "\\.")[1][[1]][[1]]
  out[[i]] <- outtemp
  
}

df <- do.call(rbind, out)

df$clust.id <- paste0(df$gene, ".", df$cluster)


df.sum <- df %>% group_by(gene,clust.id) %>% summarise(n= n()) %>% 
  arrange(desc(n)) %>% mutate(cumsum = cumsum(n),
                        max = max(cumsum))

df.sum$prop <- df.sum$cumsum / df.sum$max

df.sum$clust.id <- factor(df.sum$clust.id, levels = df.sum$clust.id[order(df.sum$cumsum)]) 
df.sum$gene <- factor(df.sum$gene, levels = unique(df.sum$gene[order(df.sum$cumsum, decreasing = T)]))

#length(unique(df$clust.id))


#cum prop by gene

plotlablookup <- df %>% group_by(gene) %>% summarise(n_clust_bygene = max(cluster) + 1)


plotlablookup$plotlab <- paste0(plotlablookup$gene, " (",plotlablookup$n_clust_bygene, " clusters)" )

df.sum <- merge(df.sum, plotlablookup)

df.sum$gene <- factor(df.sum$gene, levels = levels(fct_infreq(df$gene)))
df.sum$plotlab <- factor(df.sum$plotlab, levels = unique(df.sum$plotlab[order(df.sum$gene) ]) )

df.sum$gene <- factor(df.sum$gene, levels = unique(as.character(df$gene)[order(as.character(df$gene)) ]))


ggplot(df.sum, aes(clust.id, n, fill = gene)) + geom_col() + facet_wrap(~plotlab, scales = "free", ncol = 4) +  theme_bw() +
  theme(axis.text.x = element_blank() , panel.grid = element_blank(), legend.position = "none") + labs(x = "", y = "Contigs per cluster") -> p1

ggplot(df, aes(fct_rev(fct_infreq(gene)), fill = gene)) + geom_bar() + coord_flip() + theme_bw() + theme(legend.position = "none", panel.grid = element_blank()) + labs(y= "Frequency", x = "") -> p2

ggarrange(ggarrange(NULL,p2, NULL, heights = c(0.1, 1, 0.1), ncol =1, nrow = 3),p1, ncol = 2, nrow = 1, widths = c(0.6,2), labels = c("A", "B")) -> cluster.sizes.plot

### contig stats

df %>% group_by(clust.id) %>% mutate(n_clust = n(), max_clust_length = max(as.numeric(length))) -> df

df$sample.id <- paste0(df$clust.id, ".", df$id)

df$prop_of_max_length <- as.numeric(df$length) / df$max_clust_length
#df$max_clust_length <- as.numeric(ma)
df$clust.id <- factor(df$clust.id, levels = unique(df$clust.id[order(df$max_clust_length)]))

df.clust.rep <- subset(df,identity == "*")

df.clust.rep$clust.id <- factor(df.clust.rep$clust.id, levels = df.clust.rep$clust.id[rev(order(df.clust.rep$max_clust_length))] )

df$clust.id <- factor(df$clust.id, levels = df.clust.rep$clust.id[rev(order(df.clust.rep$max_clust_length))] )

ggplot(df.clust.rep,  aes(clust.id, as.numeric(length)/1000, fill = gene)) + geom_col()  + theme_bw() + theme(axis.text.x = element_text(size = 4, angle = 90, vjust = 0.5), axis.title.x = element_blank(), legend.title = element_blank()) + labs(y = "Max length (kbp)") -> p3

#ggplot(df.clust.rep,  aes(fct_rev(fct_reorder(clust.id,max_clust_length)), fill = gene)) + geom_bar()  + theme_bw() + theme(axis.text.x = element_text(size = 4, angle = 90), legend.position = "none") + labs(x= "Cluster ID", y = "Length of representative member(bp)")

ggplot(df,  aes(clust.id, prop_of_max_length, fill = gene)) +  geom_boxplot(outlier.size = 0.3)  +  theme_bw() + theme(axis.text.x = element_text(size = 4, angle = 90, vjust = 0.5), axis.title.x = element_blank(), legend.title = element_blank()) + labs(y = "Length (as % of max)")  -> p4

df.clusts <- subset(df, identity == "*") 
df$identity[df$identity == "*"] <- 100
ggplot(df,  aes(clust.id, as.numeric(identity)/100, fill = gene)) +  geom_boxplot(outlier.size = 0.3)  +  theme_bw()+ theme(axis.text.x = element_text(size = 4, angle = 90, vjust = 0.5), axis.title.x = element_blank(), legend.title = element_blank()) + labs(y = "Sequence identity")  -> p5


ggplot(unique(select(df,clust.id,n_clust,max_clust_length, gene)),  aes(clust.id, n_clust, fill = gene)) +  geom_col() +  theme_bw()+ theme(axis.text.x = element_text(size = 4, angle = 90, vjust = 0.5), axis.title.x = element_blank(), legend.title = element_blank()) + labs(y = "Cluster size") -> p6

#ggarrange(ggarrange(p2,p1, ncol = 2, nrow = 1, widths = c(0.5,2), labels = c("A", "B")),
 #                 p6,p3,p4,p5, ncol = 1, nrow = 5, labels = c(NA,"C", "D","E", "F") )



```

```{r wgs-contig-stats-makeplot , echo = F, warning = F, message = F}

  ggarrange(
  ggarrange( NULL,NULL,NULL,NULL, labels = c("A","B","C","D"), ncol = 1, nrow = 4),     ggarrange(p6,p3,p4,p5, ncol = 1, nrow = 4 ,common.legend = TRUE, legend = "right")
  , ncol = 2, nrow = 1, widths = c(0.1, 1.5)) -> contig.stats.plot

```

```{r wgs-contig-ggenes-plot1-setup, echo = F, warning = F, message = F, include = F}

df.is <- read.csv(paste0(wd, "contig_cluster/results/BLAST_contigs_to_n/allAMRcontigs.blast.IS.csv"),
               stringsAsFactors = F, header = F)


names(df.is) <-   c("qseqid", "sseqid","pident", "length", 
                 "mismatch","gapopen", "qstart", "qend" , 
                 "sstart","send", "evalue", "bitscore")
ddply(df.is, "qseqid", parse_blast_op_one_contig) -> df2
df2$type <- "IS"
sapply(df2$sseqid, function(x) strsplit(x, "_")[[1]][[1]]) -> df2$sseqid
df.amr <- read.csv(paste0(wd, "contig_cluster/results/BLAST_contigs_to_n/allAMRcontigs.blast.SRST2.csv"),
                   stringsAsFactors = F, header = F)
names(df.amr) <-   c("qseqid", "sseqid","pident", "length", 
                 "mismatch","gapopen", "qstart", "qend" , 
                 "sstart","send", "evalue", "bitscore")
apply(df.amr, 1, function(x) strsplit(x[2], "__")[[1]][[3]]) -> df.amr$sseqid
ddply(df.amr, "qseqid", parse_blast_op_one_contig) -> df.amr.2
df.amr.2$type <- "AMR.gene"
df.pl <- read.csv(paste0(wd, "contig_cluster/results/BLAST_contigs_to_n/allAMRcontigs.blast.pfinder.csv"),
                  stringsAsFactors = F, header = F)
names(df.pl) <-   c("qseqid", "sseqid","pident", "length", 
                     "mismatch","gapopen", "qstart", "qend" , 
                     "sstart","send", "evalue", "bitscore")
ddply(df.pl, "qseqid", parse_blast_op_one_contig) -> df.pl.2
df.pl.2$type <- "plasmid"

apply(df.pl.2[2],1, function(x) strsplit(x,"_1")[[1]][[1]] ) -> df.pl.2[2]
apply(df.pl.2[2],1, function(x) strsplit(x,"\\(")[[1]][[1]] ) -> df.pl.2[2]
apply(df.pl.2[2],1, function(x) strsplit(x,"_")[[1]][[1]] ) -> df.pl.2[2]

df.f <- rbind(df2, df.amr.2, df.pl.2)



#df.clusts <- subset(df, identity == "*") 

sub("ctxm", "CTX-M-", df.clusts$gene) -> df.clusts$gene
sub("shv", "SHV-", df.clusts$gene) -> df.clusts$gene
sub("tem", "TEM-", df.clusts$gene) -> df.clusts$gene
paste0(".", df.clusts$contig) ->df.clusts$contig

merge(df.f, select(df.clusts, contig, gene, clust.id, n_clust), by.x = "qseqid", by.y = "contig", all.x =T ) -> df.f
#sub("_unknown","", df.f$sseqid) -> df.f$sseqid

## get ready to plot genes


df.f$direc <- TRUE
df.f$direc[df.f$sstart > df.f$send] <- FALSE


df.f15 <- subset(df.f, gene == "CTX-M-15")

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n

#print(contigs_n %>% dplyr::slice(1:20))

# top 20 cover 78% of CTXM15
# top 10 cover 62%

ctxm15.1_10 <- df.sum %>% filter(gene == "ctxm15") %>% arrange(desc(n)) %>% dplyr::slice(1:20)
c#txm15.11_20 <- df.sum %>% filter(gene == "ctxm15") %>% dplyr::slice(11:20)

levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, clust.id %in% ctxm15.1_10$clust.id )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-15")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])
cat("meh1.02")
ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) + geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_discrete(name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c15




df.f15 <- subset(df.f, gene == "CTX-M-27")

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n

#print(contigs_n %>% dplyr::slice(1:20))

# top 20 cover 78% of CTXM15
# top 10 cover 62%

#ctxm15.1_10 <- df.sum %>% filter(gene == "ctxm15") %>% arrange(desc(n)) %>% dplyr::slice(1:20)
#c#txm15.11_20 <- df.sum %>% filter(gene == "ctxm15") %>% dplyr::slice(11:20)

levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-27" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-27")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3), name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c27

df.f15 <- subset(df.f, gene == "SHV-12")

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n

#print(contigs_n %>% dplyr::slice(1:20))

# top 20 cover 78% of CTXM15
# top 10 cover 62%

#ctxm15.1_10 <- df.sum %>% filter(gene == "ctxm15") %>% arrange(desc(n)) %>% dplyr::slice(1:20)
#c#txm15.11_20 <- df.sum %>% filter(gene == "ctxm15") %>% dplyr::slice(11:20)

levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15
cat("meh1.05")
df.f15.1 <- subset(df.f15, gene == "SHV-12" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "SHV-12")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

#df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.s12

#####
######

df.f15 <- subset(df.f, gene == "CTX-M-14")

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n

#print(contigs_n %>% dplyr::slice(1:20))

# top 20 cover 78% of CTXM15
# top 10 cover 62%

#ctxm15.1_10 <- df.sum %>% filter(gene == "ctxm15") %>% arrange(desc(n)) %>% dplyr::slice(1:20)
#c#txm15.11_20 <- df.sum %>% filter(gene == "ctxm15") %>% dplyr::slice(11:20)
cat("meh1.1")
levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-14" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-14")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

#df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c14

cat("meh1.4")
#### ctxm-9

df.f15 <- subset(df.f, gene == "CTX-M-9")

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n
levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-9" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-9")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c9

####
####

# CTXM 3

df.f15 <- subset(df.f, gene == "CTX-M-3")
df.f15$sseqid[df.f15$sseqid == "CTX-M-15"] <- "CTX-M-3"

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n
levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-3" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-3")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

#df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c3

####
####

# CTXM 16

df.f15 <- subset(df.f, gene == "CTX-M-16")
#df.f15$sseqid[df.f15$sseqid == "CTX-M-15"] <- "CTX-M-3"

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n
levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-16" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n

cat("meh1.8")
df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-16")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

#df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c16

####
####

# CTXM 1

df.f15 <- subset(df.f, gene == "CTX-M-1")
#df.f15$sseqid[df.f15$sseqid == "CTX-M-15"] <- "CTX-M-3"

# how many to plot

(unique(df.f15 %>% select(clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n
levels.df.f15 <- unique(select(df.f15, qseqid, n_clust))

df.f15$clust.id <- factor(df.f15$clust.id, levels = unique(df.f15$clust.id[order(df.f15$n, decreasing = T)]))
df.f15$qseqid <- factor(df.f15$qseqid, levels = levels.df.f15$qseqid[order(levels.df.f15$n_clust)])

ddply(df.f15, "qseqid", flip_one_contig, df.clusts) -> df.f15
ddply(df.f15, "qseqid", trim_one_contig, 10000) -> df.f15

df.f15.1 <- subset(df.f15, gene == "CTX-M-1" )
(unique(df.f15.1 %>% select(qseqid, clust.id, n_clust))) %>% arrange(desc(n_clust)) -> contigs_n


df.f15.1$clust.id <- as.character(df.f15.1$clust.id )
df.f15.1$qseqid <- as.character(df.f15.1$qseqid)

subset(df.f15.1, pident >= 95) -> df.f15.1
#subset(df.f15.1, !(pident != 100 & type == "AMR.gene") ) -> df.f15.1


#levels.df.f15.1 <- unique(select(df.f15.1, qseqid, n_clust))
#df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels = levels.df.f15.1$clust.id[order(levels.df.f15.1$n_clust)])

df.f15.1$qseqid <- factor(df.f15.1$qseqid, levels =  contigs_n$qseqid[order(contigs_n$n_clust, decreasing = T)])

df.f15.1$clust.id <- factor(df.f15.1$clust.id, levels =  contigs_n$clust.id[order(contigs_n$n_clust, decreasing = T)])
#names(df.f15.1)[names(df.f15.1) == "typo"] <- "type"

dummies1 <- make_alignment_dummies(
  df.f15.1,
  aes(xmin = qstart, xmax = qend, y = clust.id, id = sseqid, forward = direc),
  on = "CTX-M-1")

dummies1$direc <- TRUE
dummies1$type <- NA

df.f15.1$sseqid[df.f15.1$sseqid == "TEM-217"] <- "TEM-95"

#df.f15.1$type[df.f15.1$sseqid == "CTX-M-15"] <- "CTX-M-15"

#cols <- (hue_pal()(9)[c(1,2,4,6)])
#cols <- (RColorBrewer::brewer.pal(4,"Set3")[c(4,2,1,3)])

# fudge to stop overplotting

#df.f15.1$sseqid[df.f15.1$sseqid == "Tn5393"] <- ""

ggplot(df.f15.1[order(df.f15.1$type, decreasing = T),], aes(xmin = qstart, xmax = qend, y = clust.id, fill = type, label = sseqid, forward = direc)) +
  geom_gene_arrow(arrowhead_height = unit(4, "mm"), arrowhead_width = unit(1, "mm"), arrow_body_height = unit(4,"mm")) +
    geom_blank(data = dummies1) +
  facet_wrap(~ clust.id, scales = "free", ncol =1) + theme_genes() + 
  #theme(legend.position="none") +#  geom_gene_arrow(arrowhead_height = unit(5, "mm"), arrowhead_width = unit(1, "mm")) +
  geom_gene_label(align = "left",size = 5) + theme_genes() +  theme(legend.position = "bottom") + scale_fill_manual(values = hue_pal()(3),name = "", labels = c("AMR gene", "Insertion sequence (IS)", "Plasmid replicon") ) + ylab("") -> p.c1

ggarrange(p.c15, p.c27, p.s12, nrow = 3, ncol = 1, heights = c(2,1,0.5), labels = c("A", "B", "C")) -> contigs1.plot

cat("meh2")
```

```{r wgs-contig-ggenes-plot2-setup, echo = F, warning = F, message = F}

ggarrange(p.c14, p.c9, p.c3 , p.c16, p.c1, nrow = 5, ncol = 1, heights = c(.5,.7,.2,.2,.2),labels = c("A", "B", "C", "D", "E")) -> contigs.plot2

```

```{r wgs-contig-map-to-tree, echo = F, warning = F, message = F, fig.cap="A: Frequency distribution of ESBL genes in included samples. B: Frequency distribution of samples per ESBL-cluster, stratified by gene. C: ESBL-cluster membership mapped back to phylogeny.", out.extra='', fig.scap="ESBL-clusters mapped back to phylogeny", fig.width = 8, fig.height = 8}

df.onehot <- dcast(select(df, Lane, clust.id ), Lane ~ clust.id, fun.aggregate = base::length)

rownames(df.onehot) <- df.onehot$Lane


df.onehot[c("Lane", names(apply(df.onehot[-1],2, sum)[order(apply(df.onehot[-1],2, sum), decreasing = T)]))] -> df.onehot

sapply(df.onehot[-1], as.character) -> df.onehot[-1]


ggtree(tree) %>% gheatmap(df.onehot[-1],  font.size = 1.5,
                          colnames_position = "top", colnames_angle = 90, colnames_offset_y = 30,
                          width = 3, color = NA) + scale_fill_manual(values = c("lightgrey", "black", "white")) + theme(legend.position = "none") + annotate("text", x= 0.4, y =540, label = "ESBL contig cluster") -> cont.tree


ggarrange(cluster.sizes.plot, cont.tree, ncol = 1, nrow =2 ,labels = c(NA, "C"), heights = c(1, 2))


```

#### Assessing for heathcare-associated lineages

Having clustered bacteria and MGE using _hierBAPS_ and _cd-hit_ respectively, I then mapped the location of sample collection bact to the phylogeny and used the _hierBAPS_ SCs to assess for healthcare associated lineages (Figure \@ref(fig:wgs-hospvscommunity-map-to-tree). In general, healthcare-associated isolates were distributed throughout the tree and across all SCs, rather than there being a clear hospital-associated lineage. The exception to this was SC23, corresponding to MLST 410, which was slightly more likely to be healthcare associated. When comparing the proportion of healthcare associated samples within each SC to the remained of samples, SC23 had a statistically significantly increased proportion of healthcare associated samples (p = 6.3x10^-4^, threshold of significance following Bonferroni correction 1.0x10^-3^), though it was by no means health-facility restriced: 50% (21/42) of SC23 samples were isolated in the community.

```{r wgs-hospvscommunity-map-to-tree, echo = F, warning = F, message = F, fig.cap="A: Location of sample isolation mapped back to phylogeny B: Distribution of location of sample isolation stratified by hierBAPS cluster. In each case, community isolates include those cultured from samples collected on the first day of hospital admissison, in-hospital isolates are from patients who have been hospitalised > 24 hrs and recent discharge isolates are from patients who have been discharged from hospital within the last 2 weeks. Sequence cluster 23, highlighted in red, showed a statistically sigificant association with hospitalisation (see text).", out.extra='', fig.scap="Healthcare association of isolates mapped to phylogeny", fig.width = 8, fig.height = 5.5}


sample_ids$isolated_in <- "Community"

sample_ids$isolated_in[(sample_ids$data_date < (sample_ids$hospoutcomedate + 14)) & sample_ids$arm !=3] <- "Hospital - recent dc"
sample_ids$isolated_in[(sample_ids$data_date < (sample_ids$hospoutcomedate)) & sample_ids$arm !=3] <- "In-Hospital"

sample_ids$isolated_in[sample_ids$visit ==0] <- "Community"

sample_ids$Lane <- sub("#","_",sample_ids$Lane)

rownames(sample_ids) <- sample_ids$Lane

col <- c(hue_pal()(3), "white", "lightgrey","black", "white")
names(col) <- c("1","2","3","Community","Hospital - recent dc", "In-Hospital",  "NA")


col <- c(hue_pal()(3), "grey86", "grey45", "black", "white")
names(col) <- c("1","2","3","Community","Hospital - recent dc", "In-Hospital",  "NA")

ggtree(tree) %>%
  gheatmap(select(sample_ids, isolated_in), width = 0.2, color = NA, colnames = F) +
  scale_fill_manual(values = col,labels = c( "Community","Hospital - recent dc", "In-Hospital","")) +
  geom_hilight(node = 727, fill = "red") + theme(legend.position = "none") -> p1


subset(sample_ids, Lane %in% tree$tip.label) -> sample_ids
sample_ids <- merge(sample_ids, hbdf, by.x = "Lane", by.y = "Isolate", all.x = T)

fudgedat <- data.frame( BAPS.l2 = as.character(23), count = nrow(subset(sample_ids, BAPS.l2 == 23)), isolated_in = "fudge")

ggplot(sample_ids, aes(fct_rev(fct_infreq(BAPS.l2)), fill = isolated_in)) + 
    geom_bar(colour = "black") + coord_flip() + xlab("level 2 BAPS clusters") + ylab("Count") +
    theme_bw() + 
  theme(legend.position = "right") + scale_fill_manual(values = col, name = element_blank()) +
  geom_col(data = fudgedat, aes(BAPS.l2, count), fill = "red", alpha = 0.3) -> p2

ggarrange(p1,p2, ncol = 2, labels = c("A", "B"), widths = c(0.6, 1))
```

#### Assessing for within-patient conservation of lineage or MGE

To answer the question as to what elements (bacteria or MGE) are conserved within individuals across time I first compared all-against-all pairwise SNP distance between and within patients; first as a scatter plot, and then, because of significant overplotting, as a density plot (Figure \@ref(fig:wgs-within-vs-between-snpdist). This suggested that there are a cluster of points close to the origin in the within-patient plot that are not seen in the between-patient plot: before approxiimately 50 days, there are more similar within-patient isolates than seen in the between-patent isolates. Dichotomising time at 50 days (based on inspection of the density plots) and performing a Kruskal-Wallace test found a statistically significant difference between the before 50 day and after 50 day pairwsie SNP distance distribution in the within patient stratum (p = 0.008) but not in the between-patient stratum (p = 0.07). After 50 days, the distribution of between- and within- patent SNP distances are similar (p = 0.45). However it is clear form the plots that even at small $t$ and within-participant, there is significant diversity is the SNP distances, and that some isolates close together in time, within the same particpant, are only distantly related.

Having confirmed that there is a signal for within-participant temporal conservation of ESBL-E, I then sought to determine if the sequence clusters and ESBL-clusters were similarly conserved over time, and if so, which was the more conserved.

```{r, wgs-within-vs-between-snpdist, echo = F, warning = F, message = F, fig.cap="Within and between participant pairwise SNP distances. A: Scatterplot of pairwise SNP distances as a function of time with GAM model fitted curve. B: Pairwise SNP distance as function of time as a 2D density plot, showing cluster of isolates close to origin that are close together in time and SNP-distance. C: Pairwsise SNP distance distribution before and after 50 days, within and between patients, showing statistically significant descreas ein pairwise SNP distance within patients before 50 days. After 50 days, between- and within- patient distributuions are similar.", out.extra='', fig.scap="Within- and between pairwise SNP distance of isolates", fig.width = 8, fig.height = 5}

subset(data.frame(table(sample_ids$Supplier.Name)), Freq > 1)$Var1 -> doubles
select(subset(sample_ids, Supplier.Name %in% doubles), Lane, Supplier.Name) -> doubles.lanes

doubles.lanes[order(as.character(doubles.lanes$Supplier.Name)),] -> doubles.lanes

drop <- doubles.lanes[-seq(1, 14, 2),]$Lane

sample_ids <- subset(sample_ids, !(Lane %in% drop))

## add metadata to SNP dists


snpdists.df <- merge(snpdists.df, select(sample_ids, Lane, pid, data_date), by.x = "Var1", by.y = "Lane")
names(snpdists.df)[names(snpdists.df) == "pid"] <- "pid.1"
names(snpdists.df)[names(snpdists.df) == "data_date"] <- "data_date.1"

snpdists.df <- merge(snpdists.df, select(sample_ids, Lane, pid, data_date), by.x = "Var2", by.y = "Lane")
names(snpdists.df)[names(snpdists.df) == "pid"] <- "pid.2"
names(snpdists.df)[names(snpdists.df) == "data_date"] <- "data_date.2"

snpdists.df$category <- NA

snpdists.df$category[snpdists.df$pid.1 == snpdists.df$pid.2] <- "Within Patient"
snpdists.df$category[snpdists.df$pid.1 != snpdists.df$pid.2] <- "Between Patient"

snpdists.df$t <- abs(as.numeric(snpdists.df$data_date.1 - snpdists.df$data_date.2))

ggplot(subset(snpdists.df,!is.na(pid.1) & !is.na(pid.2)), aes(t, value)) + geom_point(alpha = 0.05) + coord_cartesian(xlim = c(0,200)) + 
  geom_smooth() + theme_bw() + scale_fill_viridis(option = "magma") + 
  xlab("Pairwise time difference (days)") +
  ylab("SNP distance") +   facet_grid(~ category) + ylim(c(0,30000)) -> q1

ggplot(subset(snpdists.df,!is.na(pid.1) & !is.na(pid.2)), aes(t, value)) + stat_density_2d(aes(fill = ..density..), contour = FALSE, geom= "tile") + coord_cartesian(xlim = c(0,200)) +  
  facet_grid(~ category) +theme_bw() + scale_fill_viridis(option = "plasma") + 
  xlab("Pairwise time difference (days)") +
  ylab("SNP distance") + theme(legend.position = 'none') + ylim(c(0,30000)) -> q2


snpdists.df$category2 <- "< 51 days"

snpdists.df$category2[snpdists.df$t > 50] <- "51+ days"
ggplot(subset(snpdists.df, !is.na(category)), aes(x=category2, y= value) ) +  geom_jitter(alpha = 0.2) + geom_boxplot(alpha = 0.8) +
  facet_wrap(~ category) + theme_bw() + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + ylab("SNP distance") +
  xlab("") + stat_compare_means(method = "kruskal", size = 3, label.y = 31000, label.x = 1.2, aes(label = paste0("p = ", ..p.format..))) -> q3

ggarrange(ggarrange(q1,q2, ncol = 1, nrow = 2 , labels = c("A", "B")), ggarrange(NULL, q3, NULL, ncol = 1, nrow = 3, heights = c(0.2,3,1,0.2),labels = c(NA , "C", NA)) , ncol = 2, nrow = 1, widths = c(1.3,1))

```

```{r, wgs-setup-rollprop, echo = F, message=F, warning=F, echo = F, warning = F, message = F, fig.cap="Probability of any two samples from within a given participant containing the same ESBL-cluster (A, left panel) or being a member of the same hierBAPS cluster (A, right panel). Time is windowed at +/- 5 days around the time indicated on the x axis. Dotted line is the probability that two samples would belong the the same group by chance, constructed by randomly sampling 1000 sample pairs. B: proportion of samples that contain the same herBAPS cluster alone, or ESBL-cluster alone, or both, demonstrating that the ESBL cluster-hierBAPS cluster pairing is the most conserved of the three. ", out.extra='', fig.scap="Within-patient ESBL-cluster and hierBAPS clustering as a function of time", fig.width = 7, fig.height = 5}

# make the df for assessnig contig cluster.
# we'll accept *any* conserved cluster (f ther are more than 1) as a match

contigs <- melt(select(df, Lane, clust.id))
contigs %>% group_by(Lane) %>% mutate(id = paste0("contig", row_number())) -> contigs
dcast(contigs, Lane ~ id, value.var = "clust.id") -> contigs
sample_ids <- merge(sample_ids, contigs, all.x = T)

# make crossed df


sid_cross <- merge(dplyr::select(sample_ids, pid, Lane, data_date, BAPS.l2, contig1, contig2, contig3), 
                   dplyr::select(sample_ids, pid, Lane, data_date, BAPS.l2,  contig1, contig2, contig3), by = "pid")
sid_cross <- subset(sid_cross, Lane.x != Lane.y)
apply(select(sid_cross, Lane.x, Lane.y), 1, function(x) paste(sort(x), collapse = "")) -> sid_cross$key
subset(sid_cross, !duplicated(key) ) -> sid_cross
sid_cross$t <- abs(as.numeric(sid_cross$data_date.y - sid_cross$data_date.x))

sid_cross$same_BAPscl <- sid_cross$BAPS.l2.x == sid_cross$BAPS.l2.y

sid_cross$same_contig <- NA
for (i in 1:nrow(sid_cross)) {
  c1 <- sid_cross[i,5:7]
  c2 <- sid_cross[i,11:13]
  sid_cross$same_contig[i] <- c1 %in% c2 & !is.na(c1) & !is.na(c2)
}



prop.baps <- data.frame( t = seq(0,220,1))
prop.baps$e <- NA
prop.baps$n <- NA
prop.cont <- prop.baps
wind <- 10

for (i in 1:nrow(prop.baps)) {
  temp <- subset(sid_cross, t > (prop.baps$t[i] - wind) & t < (prop.baps$t[i] + wind  ))
  prop.baps$e[i] <- sum(temp$same_BAPscl)
  prop.baps$n[i] <- length(temp$same_BAPscl)
  prop.cont$e[i] <- sum(temp$same_contig)
  prop.cont$n[i] <- length(temp$same_contig)
}
prop.baps$type <- "hierBAPS cluster"
prop.cont$type <- "ESBL-cluster"

  
rollprop$prop <- apply(rollprop[1:3], 1, function(x) binom.test(x[2], x[3])$estimate)
rollprop$lci <- apply(rollprop[1:3], 1, function(x) binom.test(x[2], x[3])$conf.int[1])
rollprop$uci <- apply(rollprop[1:3], 1, function(x) binom.test(x[2], x[3])$conf.int[2])


# null line

null1 <- sample_n(select(sample_ids, pid, t, BAPS.l2, contig1, contig2,contig3, data_date), 1000 , replace = T)
names(null1) <- paste0(names(null1), ".x")
null2 <- sample_n(select(sample_ids, pid, t, BAPS.l2, contig1, contig2,contig3, data_date), 1000 , replace = T)
names(null2) <- paste0(names(null2), ".y")
null <- cbind(null1, null2)

null$same_BAPscl <- null$BAPS.l2.x == null$BAPS.l2.y

null$same_contig <- NA
for (i in 1:nrow(null)) {
  c1 <- null[i,4:6]
  c2 <- null[i,11:13]
  null$same_contig[i] <- c1 %in% c2 & !is.na(c1) & !is.na(c2)
}

null$t <- abs(as.numeric(null$data_date.y - null$data_date.x))

#prop.baps <- data.frame( t = seq(0,220,1))
#prop.baps$e <- NA
#prop.baps$n <- NA

#prop.cont <- prop.baps
#for (i in 1:nrow(prop.baps)) {
#  prop.baps$e[i] <- sum(temp$same_BAPscl)
# prop.baps$n[i] <- length(temp$same_BAPscl)
#  prop.cont$e[i] <- sum(temp$same_contig)
#  prop.cont$n[i] <- length(temp$same_contig)
#}

nullprop <- data.frame(type = c("hierBAPS cluster","ESBL-cluster"),
                       e =  c(sum(null$same_BAPscl), sum(null$same_contig)),
                       n = c(length(null$same_BAPscl), length(null$same_contig)))

#  prop.cont$e[i] <- sum(temp$same_contig)
#  prop.cont$n[i] <- length(temp$same_contig)



nullprop$prop <- apply(nullprop[2:3], 1, function(x) binom.test(x[1], x[2])$estimate)
nullprop$lci <- apply(nullprop[2:3], 1, function(x) binom.test(x[1], x[2])$conf.int[1])
nullprop$uci <- apply(nullprop[2:3], 1, function(x) binom.test(x[1], x[2])$conf.int[2])



ggplot(rollprop, aes(t, prop, group = type)) + geom_line() + 
    geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.3, color = NA) + 
    coord_cartesian(xlim = c(0,100), ylim  = c(0,0.4)) + 
    geom_hline(data = nullprop, aes(yintercept = prop,group = type), linetype = "dashed") + 
  theme_bw() + facet_wrap(~ type) + theme(legend.position = "none") + xlab("Time (days)") + ylab("Proportion") -> p10

# for bar chart need to cross all


tidyr::crossing(dplyr::select(sample_ids, pid, Lane, data_date, contig1,contig2, contig3, BAPS.l2),
         dplyr::select(sample_ids, pid, Lane, data_date, contig1,contig2, contig3, BAPS.l2)) -> crossall

crossall <- subset(crossall, Lane != Lane1)
apply(select(crossall, Lane, Lane1), 1, function(x) paste(sort(x), collapse = "")) -> crossall$key
subset(crossall, !duplicated(key) ) -> crossall


for (i in 1:nrow(crossall)) {
  c1 <- crossall[i,4:6]
  c2 <- crossall[i,11:13]
  crossall$same_contig[i] <- c1 %in% c2 & !is.na(c1) & !is.na(c2)
}
crossall$same_hierb <- crossall$BAPS.l2 == crossall$BAPS.l21

crossall$same_pt <- crossall$pid == crossall$pid1


crossall %>% group_by(same_pt) %>% dplyr::summarise(same_hierb.only = sum(same_hierb == TRUE & same_contig == FALSE),
                                             same.clu.only = sum(same_hierb == FALSE & same_contig == TRUE),
                                             same.both = sum(same_hierb == TRUE & same_contig == TRUE),
                                             neither = sum(same_hierb == FALSE & same_contig == FALSE),
                                             tots = n()) %>% filter(!is.na(same_pt)) -> crossall.sum
melt(crossall.sum) -> df.m

df.m$same_pt[df.m$same_pt == "FALSE"] <- "Between patient"
df.m$same_pt[df.m$same_pt == "TRUE"] <- "Within patient"

df.m$value_norm <- df.m$value
df.m$value_norm[df.m$same_pt == "Within patient"] <- df.m$value_norm[df.m$same_pt == "Within patient"] / max(subset(df.m, same_pt == "Within patient")$value)
df.m$value_norm[df.m$same_pt == "Between patient"] <- df.m$value_norm[df.m$same_pt == "Between patient"] / max(subset(df.m, same_pt == "Between patient")$value)

df.m$variable <- as.character(df.m$variable)
df.m$variable[df.m$variable == "same_hierb.only"] <- "Same hierBAPS-clusetr only"
df.m$variable[df.m$variable == "same.clu.only"] <- "Same ESBL-cluster only"
df.m$variable[df.m$variable == "same.both"] <- "Same ESBL and hierBAPS cluster"

df.m$variable <- factor(df.m$variable, levels = rev(c("Same ESBL and hierBAPS cluster","Same ESBL-cluster only" ,"Same hierBAPS-clusetr only", "neither"  )))

#Calculate fishers

mat.both <- matrix(c(1978, 33,107488 - 1978 ,392 - 33), nrow = 2,
                      dimnames =
                          list(c("Between pt", "Within pt"),
                               c("Same", "Not")))


mat.bug <- matrix(c(3305, 15,107488 - 3305 ,392 - 15), nrow = 2,
                      dimnames =
                          list(c("Between pt", "Within pt"),
                               c("Same", "Not")))

mat.mge <- matrix(c(1711, 6,107488 - 1711 ,392 - 6), nrow = 2,
                      dimnames =
                          list(c("Between pt", "Within pt"),
                               c("Same", "Not")))


ggplot(subset(df.m,variable != "tots" & variable != "neither"), aes(variable, value_norm, fill = same_pt)) + geom_col(position = "dodge")  +
coord_flip() + guides(fill = guide_legend(reverse = TRUE)) +
  theme(legend.title = element_blank()) + ylab("Proportion") + xlab("") +
  annotate(geom = "segment", y = 0.09, yend = 0.09, x = 2.7, xend = 3.3) + 
  annotate(geom = "segment", y = 0.09, yend = 0.09, x = 1.7, xend = 2.3) +
  annotate(geom = "segment", y = 0.09, yend = 0.09, x = 0.7, xend = 1.3) +
    annotate(geom = "text", y = 0.11, x = 3.0, label = "p < 0.001", size = 3) + 
  annotate(geom = "text", y = 0.11, x = 2.0, label = "p = 1.0", size = 3) +
  annotate(geom = "text", y = 0.11, x = 1.0, label = "p = 0.38", size = 3) + 
   ylim(c(0,0.12)) + theme_bw() -> p11
# so only smae both baps and gene cluster is increased in within-patient samples
# + ylim(c(0,0.11))
  
ggarrange(p10, p11, ncol = 1, nrow = 2, labels = c("A", "B"), heights = c(1.2,1))

```

## Conclusions and discussion

## Appendix

```{r wgs-contig-stats-plot, echo = F, warning = F, message = F, fig.scap="Summary statistics for ESBL-contig clusters", out.extra='', fig.cap="Summary statistics for 99 ESBL-containing contig clusters as deterined by \\textit{cd-hit}. A: Number of contigs per cluster. B: Length (kbp) of longest sample in each cluster. This is defined as the cluster representative sample by \\textit{cd-hit} to which all other samples are compared for the purposes of length and sequence identity. C: Distribution of contig lengths by cluster expressed as a proportion of longest contig length. D: Distribution of sequence identity of cluster members compared to representative member, by cluster.", fig.width = 6, fig.height = 7}

contig.stats.plot

```

```{r wgs-contig-ggenes-plot1, echo = F, warning = F, message = F, fig.scap="AMR genes, IS and plasmid replicon content of ESBL-clusters, part 1", out.extra='', fig.cap="AMR genes, insertion sequences (IS) and plasmid replicons identified in the representative contig of each contig cluster, stratified by by ESBL gene and ordered by number of samples of cluster. IS26 is very frequently associated with a 108bp fragment of \\textit{catB4} chloramphenicol resistance gene, shown as a red fragnemt within the green IS26 element. A: \\textit{blaCTXM15}, B: \\textit{blaCTXM27} , C: \\textit{blaSHV12}. Plots show furthest IS/AMR gene or plasmid replicon up to +/- 10,000bp from the ESBL gene of interest.", fig.width = 13, fig.height = 15}

contigs1.plot

```

```{r wgs-contig-ggenes-plot2, echo = F, warning = F, message = F, fig.cap="AMR genes, insertion sequences (IS) and plasmid replicons identified in the representative contig of each contig cluster, stratified by by ESBL gene and ordered by number of samples in cluster. IS26 is very frequently associated with a 108bp fragment of \\textit{catB4} chloramphenicol resistance gene, shown as a red fragnemt within the green IS26 element. A: \\textit{blaCTXM14}, B: \\textit{blaCTXM9} , C: \\textit{blaCTXM3}, D: \\textit{blaCTXM16}, E: \\textit{blaCTXM1}. Plots show furthest IS/AMR gene or plasmid replicon up to +/- 10,000bp from the ESBL gene of interest.", out.extra='', fig.scap="AMR genes, IS and plasmid replicon content of ESBL-clusters, part 2", fig.width = 12, fig.height = 15}

contigs.plot2

```

