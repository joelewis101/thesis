# Longitudinal Markov models of ESBL-E carriage

\chaptermark{Modelling ESBL-E carriage}

```{r ch8-setup, include = F}
library(plyr)
library(tidyverse)
library(reshape2)
library(rstan)
library(loo)
library(kableExtra)
library(glue)
library(deSolve)
library(ggpubr)

source("other_scripts/load_metadata.R")

source("final_cleaning_scripts/load_and_clean_followup_and_enroll_labelled.R")
source("other_scripts/summary_table_functions.R")
source("final_cleaning_scripts/make_composite_hivstatus_variable.R")
source("final_cleaning_scripts/load_and_clean_hourly.R")
source("final_cleaning_scripts/load_and_clean_bloods.R")
#source("final_cleaning_scripts/load_and_clean_aetiol.R")
#source("final_cleaning_scripts/load_and_clean_hourly.R")
source("final_cleaning_scripts/load_and_clean_upto72.R")
source("final_cleaning_scripts/load_and_clean_post72.R")
source("final_cleaning_scripts/load_and_clean_hosp_oc.R")
#source("final_cleaning_scripts/load_and_clean_time_to_ab.R")
#source("final_cleaning_scripts/load_and_clean_fluid_hr1_to_6.R")
source("other_scripts/stan_helpers/arrange_stan_df_functions.R")

# lims




#panel data helper functions
source("other_scripts/panel_data_helpers/expand_covariates.R")
source("other_scripts/panel_data_helpers/sort_out_tb_rx_on_discharge.R")
source("other_scripts/panel_data_helpers/shuffle_a_in_b2.R")
source("other_scripts/panel_data_helpers/strip_post_dropout_rows.R")
source("other_scripts/panel_data_helpers/extract_covariate_exposure.R")
source("other_scripts/panel_data_helpers/collapse_covariates.R")
source("other_scripts/panel_data_helpers/ditch_everything_after_first_1.R")
source("other_scripts/panel_data_helpers/mstate_helper_functions.R")
source("other_scripts/panel_data_helpers/splice_ESBL2.R")

names(enroll)[names(enroll) == "data_date"] <- "enroll_date"
followup <- merge(followup, select(enroll, pid, arm, enroll_date), all.x = T)
followup$t <- followup$data_date - followup$enroll_date

# and load lims
source("final_cleaning_scripts/load_and_clean_lims.R")

stan.df <- read.csv("data/stan_df.csv", stringsAsFactors = F)
# ans stan df

specify_decimal <- function(x, k) trimws(format(round(x, k), nsmall=k))
```
## Chapter Overview

In this chapter, I develop time-inhomogeneous Markov models of ESBL-E carriage by individuals and fit them using the Bayesian probabilistic programming language Stan. I demonstrate that fitting these models is feasible with modest computational requirements, and that they are very flexible. I find that hospitalisation acts to increase both rate of ESBL-E acquisition and loss, with a net effect of rapidly increasing ESBL-E carriage prevalence; further, I find that antibacterial exposure acts to prolong ESBL-E carriage by reducing the rate of ESBL-E loss. It is, however, the synergistic effect of hospitalisation and antibacterial exposure that drives the rapid increase in ESBL-E carriage prevalence observed in antibacterial-exposed inpatients. I also find that co-trimoxazole preventative therapy (CPT) likely plays an important role as a determinant of long-term ESBL-E carriage. The models I have developed also support a post-exposure effect of antibacterials, such that they continue to have an effect long after they have been excreted from the body. I present hypotheses about the mechanism of such an effect along with the implications of my findings for antimicrobial stewardship interventions, and planned further work.

## Introduction and chapter aims

In Chapter 5, I presented the longitudinal ESBL-E carriage data for the three arms of the clinical study that underpin this thesis. Antibacterial-exposed, hospitalised participants (arm 1) showed a rapid increase in ESBL-E carriage prevalence, whilst antibacterial-unexposed hospitalised participants (arm 2) showed a much more modest increase. This suggests that antimicrobial exposure is the most significant determinant of acquisition of carriage; however, this unadjusted analysis is open to confounding. The participants recruited to the two arms of the study differed in important ways: antimicrobial unexposed participants were younger, less likely to be HIV-infected, with less cotrimoxazole preventative therapy (CPT) exposure, and crucially, a shorter length of hospital stay. An attempt to adjust for potential confounders using simple logistic regression models failed; therefore in this chapter I develop longitudinal models to quantify the relative roles of antibacterial exposure and hospitalisation in driving ESBL-E carriage.

There have been few prior attempts to model longitudinal ESBL-E carriage, and none where the focus was on he role of antimicrobials, including:

1. Fitting a Weibull distribution to community sample data[@Teunis2018]
2. Fitting a beta-distribution of admission and discharge carriage probability to data from trials of contact precautions in Dutch hospitals[@Kluytmans-vandenBergh2018]
3. Modelling household ESBL-E acquisition as a Markov process[@Haverkate2017]. 

None of these studies included the effect of antibacterial exposure as a covariate. The Markov model approach is an attractive method to model multi-state interval-censored data[@Hout2016], has been used with a variety of clinical datasets[@Longini1989; @Andersen1988; @Jackson2002] and is implemented in the _msm_ package in R[@Jackson2011a] where a maximum likelihood method is used to fit the models. However, _msm_ allows only stepwise-constant covariate effects, largely for reasons of computational tractability in the maximum-likelihood framework, but there is no reason to assume that the effect of antibacterial exposure, for example, will act in this fashion. The aims of this chapter, therefore, are:

1. To generalise _msm_-type models to allow true time-varying covariates;
2. To demonstrate the feasibility of fitting such models;
3. To use the fitted models to infer an unbiased estimate of the relative roles of antibacterial exposure and hospitalisation in driving ESBL-E carriage by both fitted parameter estimates and simulating different levels of exposure;
4. To compare models with and without a post-exposure effect of antibacterials to assess the support in this data for such an effect;
5. To combine the models with ESBL-E species data and with the WGS isolate typing presented in Chapter 7 to explore carriage at the level of species, _E. coli_ sequence cluster and ESBL-containing mobile genetic element.

## Methods

### Developing the models used in this chapter

In the broadest sense when constructing a model, our aim is to estimate the most likely values of the parameters of the model, $\theta$, given the data we have, $x$. The starting point for estimating likely parameter values, given a choice of model, is usually the _likelihood_: this is the probability of the data, given a set of parameter values. In standard probability notation, this is written as $P(x | \theta)$. In fact, this is not the quantity we are interested in; we would like to know $P(\theta | x )$: the probability of the parameter values, given the data. Both frequentist and Bayesian modelling approaches provide methods to estimate this quantity, but the starting point for both is the likelihood, $P(x| \theta)$, because it is usually much more straightforward to derive an expression for $P(x | \theta)$ rather than $P(\theta | x )$. I will here derive a general likelihood for a two state intermittently observed process; in order to use this likelihood, it is necessary to make some assumptions about the data generating process. I have chosen to use a Markov model, and I will then derive the likelihood for this model, describe how covariates will be incorporated, describe how the model was fit - the process taking us from the likelihood to the most likely parameter values - and finally how goodness of was fit assessed.

### General form of likelihood

First, I derive a general expression for the likelihood of a two-state intermittently observed process without making any assumptions about the model structure or functional form. Assume we have $N$ participants with any given participant $n$ in a state $S_{n}(t)$ at time $t$: either ESBL-E colonised ($S_{n}(t) = 1$) or uncolonised ($S_{n}(t) = 0$). For each participant $n$ we have a number of measurements of $S_{n}(t)$ at a number of time points. The number of measurements varies for each participant, and can be denoted by $j_{n}$, making the time of measurements $t^n_{j_{n}}$ for participant $n$; and so for each participant we know the  $j_{n}$ values $S_{n}(t^n_{j_{n}})$. 

To arrive at the likelihood for these observations, consider first the simplest situation that we have: the measurements of ESBL status at two time points, $t_{A}$ and $t_{B}$ for a single participant, $n$. The likelihood we wish to calculate, in words, is the probability of the participant being in the second observed state at time $t_{B}$, given they were in the first state at $t_{A}$ and given the parameters of the model, $\theta$. Or, mathematically:

\begin{equation} 
P(S_{n}(t_{B}) | S_{n}(t_{A}), \theta)
(\#eq:1)
\end{equation} 

Assuming all the observations are independent, the probability of  all of the states we have observed for this participant is the product of all the probabilities of the individual states:

\begin{equation} 
\prod^{j_{n}}_{k =2} P(S_{n}(t^n_{k}) | S_{n}(t^n_{k-1}), \theta )
(\#eq:2)
\end{equation} 

And the probability of observing the data we have is then simply the product of the probability of all the individual transitions:

\begin{equation} 
\prod^N_{n=1}\prod^{j_{n}}_{k =2} P(S_{n}(t^n_{k}) | S_{n}(t^n_{k-1}), \theta )
(\#eq:3)
\end{equation} 

This is the quantity that we wish to calculate: the likelihood for the observed data, $P(x|\theta)$. Note that the sum over states for an individual in equation \@ref(eq:3) starts from 2; if a participant has only one available sample then this does not provide any information about transition probabilities, and must be excluded from the analysis.

### Markov model likelihood

In order to calculate the likelihood, we need to make some assumptions about the data generating process. In this case, I have chosen to use a Markov model. Markov models are defined by instantaneous transition probabilities, analogous to the hazard of death in a survival model, which is a simple two-state Markov system. Unlike a survival model (where it is not possible to move from the death state to alive), a general Markov model is defined by a transition hazard from each state to each other state in the system. These are traditionally expressed as a Q matrix of instantaneous transition intensities[@Hout2016; @Jackson2011a] (assuming a two-state system):

\begin{equation} 
\mathbf{Q}(t) = \begin{pmatrix} q_{00}(t) & q_{01}(t) \\\ q_{10}(t) & q_{11}(t) \end{pmatrix}
(\#eq:4)
\end{equation} 

Where $q_{ij}$ represents the instantaneous transition intensity from state $i$ to state $j$. The rows of the Q-matrix must sum to 1 (every participant has to be in one state or another), so if we define the hazard of ESBL-E acquisition to be $\lambda$ and the hazard of ESBL-E loss to be $\mu$ (\@ref(fig:ESBL-twostate-diag)), the Q-matrix becomes, in our case:

\begin{equation} 
\mathbf{Q}(t) =  \begin{pmatrix} -\lambda(t) & \lambda(t) \\\ \mu(t)  & -\mu(t) \end{pmatrix} 
(\#eq:5)
\end{equation} 


However, we are not interested in the Q-matrix _per se_ but rather the probability $p_{ij}$ of starting in state $i$ at time 0 and being in state $j$ at time $t$; this can be written in matrix notation as $\mathbf{P}(t)$ and is related to $\mathbf{Q}(t)$ by the differential equations:

\begin{equation} 
\displaystyle \frac{d\mathbf{P}(t)}{dt} =  \mathbf{Q}(t) . \mathbf{P}(t)
(\#eq:6)
\end{equation} 

Where $\mathbf{Q}(t) . \mathbf{P}(t)$ is the matrix product of $\mathbf{Q}(t)$ and $\mathbf{P}(t)$. In order to evaluate $\mathbf{P}(t)$, therefore we need to solve this system of differential equations. However, there are limited situations in which these equations have analytic solutions. If the system has time constant or piecewise constant Q matrix the matrix exponential is a solution:

\begin{equation} 
\mathbf{P}(t) = e^{\mathbf{Q}}
(\#eq:7)
\end{equation} 

However, there is no reason to suspect particularly that the effect of covariates on ESBL-E carriage (e.g. antimicrobials) would be stepwise constant and so a more flexible model is needed. For general time-varying transition intensities, there is no analytic solution to the above equations. However, all is not lost: we can express the likelihood in terms of the differential equations defined by the equations above  and solve them numerically in order to calculate the likelihood. The matrix notation above can be simplified, assuming that the system starts in state 1 or 0:

\begin{equation} 
\displaystyle \frac{dP_0(t)}{dt} = -\lambda(t) P_0(t) + \mu(t) P_1(t)
(\#eq:8a)
\end{equation} 
\begin{equation} 
\displaystyle \frac{dP_1(t)}{dt} = \lambda(t) P_0(t) - \mu(t) P_1(t)
(\#eq:8b)
\end{equation} 

Where $P_i(t)$ is the probability of being in state $i$ at time t. Numerical ordinary differential equation (ODE) solvers can quickly solve these equations to calculate, for example, $P(S_{n}(t_{B}) | S_{n}(t_{A}), \theta)$ from the simplest example above: the probability that a participant $n$ at time $t_{B}$ is in a given state, given that they were in state $S_{n}(t_{A})$ at time $t_{A}$, and given the parameters $\theta$. This calculation can be completed for all measurements and participants, resulting in the likelihood of the system, $P(x | \theta)$. 

In order to use this model for inference, two questions must be addressed: first, how to incorporate time-varying covariates; and second, how to practically fit the model. I address each of these questions below.

```{r ESBL-twostate-diag, echo = F, warning = F, message = F,fig.scap='Two state ESBL-E model', out.extra='', fig.cap = 'Two state ESBL-E model showing instanteneous hazard of ESBL-E acquisition ($\\lambda$) or loss ($\\mu$).', out.height = '20%',fig.align = 'center'}


knitr::include_graphics("chapter_9/state_diag.png")
```

### Incorporating covariates: a proportional hazard model

I have chosen to incorporate covariates using a proportional-hazards model, following both Marshall and Jones[@Marshall1995] and the _msm_ package in R[@Jackson2011a]. In this model the transmission intensities become:

\begin{align} 
\lambda(t) = \lambda_{0}\exp{(\beta_0x_{0}(t) + \beta_1x_{1}(t) + ...\beta_mx_{m}(t))} \\
\mu(t) = \mu_{0}\exp{(\alpha_0x_{0}(t) + \alpha_1x_{1}(t) + ...\alpha_mx_{m}(t))}
(\#eq:9b)
\end{align} 

Where the $x_{k}, k = 1,2...m$ are the $m$ time-varying covariates in the model and the coefficients $\alpha_{k}$ and $\beta_{k}$ are the coefficients of these covariates; these have a straightforward interpretation in that the exponential, $e^{\alpha_{k}}$ or$e^{\beta_{k}}$ can be interpreted as a hazard ratio, as per a simple survival model. 

An assumption then needs to be made about the functional form of $x_{m}$. In a stepwise-constant covariate model in which an exposure occurs between $t_{A}$ and $t_{B}$,  $x(t)$ would take the value 1 for all $t_{A} \le t \le t_{B}$t and 0 at other times, meaning that the effect of the exposure does not persist once it ceases. Though this may be plausible for some exposures, it seems possible that antimicrobial exposure (for example) might have a longer lasting effect or post-exposure effect; in order to explore this possibility, it is necessary to decide on a flexible, plausible, functional form that such an effect might take. I have decided to use an exponential function, such that:

\begin{equation}
x_{k}(t) = 
\begin{cases} 
0  & \text{if } t < t_{A}\\
1   & \text{if } t_{A} \le t \le t_{B}\\
\exp{\displaystyle \frac{-(t - t_{B})}{\gamma_{k}}} & \text{if } t > t_{B}\\
\end{cases}
(\#eq:10)
\end{equation}

Where the parameter $\gamma_{k}$ is a model parameter for each of the covariates, to be estimated from the data, and is related to the half life, $t^{k}_{\frac{1}{2}}$ of the decay of the effect of the exposure by:

\begin{equation}
t^k_{\frac{1}{2}} = \gamma_{k}\ln(2) \approx 0.69\gamma_{k}
(\#eq:11)
\end{equation}

This parametrisation has the advantage that the data can fit the size of the parameters $\gamma_{k}$; if the data are more in keeping with a stepwise effect of the covariates, then a small ($\ll 1$) $\gamma$ would approximate a step function and this could be fit by the model. Alternatively a larger $\gamma$ would result in the effect of the covariate persisting after exposure, but decaying over time. This allows us to test the hypothesis that antimicrobial exposure (for example) has an effect that persists once exposure finishes, by both the magnitude of the fitted $\gamma_{k}$, and comparing stepwise-constant covariate models to models incorporating the $\gamma_{k}$ parameters.

The parameters of the model all have the advantage of having a reasonably intuitive meaning: $\exp(\alpha)$ and $\exp(\beta)$ are the hazard ratio for ESBL-E loss and acquisition, respectively; the reciprocals of $\lambda$ and $\mu$ are the mean time in days spent in the uncolonised or colonised states, respectively; and $\ln(2)\gamma \approx 0.69\gamma$, as stated above, is the half life of the post-exposure effect.

### Building and fitting models 

The Bayesian probabilistic programming language _Stan_ incorporates an ordinary differential equation solver, and will allow the fitting of the model in a Bayesian framework[@Carpenter2017]. In this framework, Bayes' rule  allows us to estimate our probability distribution of interest, $P(\theta | x)$, called the _posterior_ in the Bayesian framework, a long as we provide a _prior_, encoding our prior beliefs about the values of the parameters as a probability distribution for each parameter[@Gelman]. Stan then uses the No-U-Turn Sampler (NUTS) implementation of Markov-chain Monte-Carlo (MCMC) sampling[@Hoffman2014] to sample from the posterior to provide $P(\theta | x)$. It can be shown that, given infinite chain length, MCMC estimates are guaranteed to be unbiased samples from the posterior; when this occurs the chains have said to converged. Unfortunately there is no diagnostic test that guarantees convergence, rather tests that are necessary but not sufficient to ensure convergence: running multiple chains from different starting points with examination of traceplots to show within and between mixing of chains, and the $\hat{R}$ statistic, which measures mixing of the two halves of an MCMC chain. At convergence, $\hat{R}$ should be close to 1[@Gelman]. In addition, divergences - failure in the NUTS sampler - can be indicative of difficult topography in the posterior at the area where the divergences occur, and suggest that parameter estimates may be biased[@Betancourt2017], and are flagged by Stan. All of these tests were used to diagnose convergence.

Two decisions must be made in order to fit the model: covariates must be chosen to include, and priors specified. Models were built sequentially to predict ESBL-E status, starting from the simplest possible, then adding complexity:

* _Model 1:_ Composite antibacterial variable (includes all antibacterials) and hospitalisation variable as explanatory variables, both included with stepwise constant effect and no post exposure effect.

* _Model 2:_ As per model 1 except antibacterial exposure modelled with decaying post-exposure effect.

* _Model 3:_ Hospitalisation, TB therapy and co-trimoxazole exposure all modelled as stepwise constant covariates. All other antibacterials included in a composite variable with decaying post-exposure effect.

* _Model 4:_ Hospitalisation, TB therapy and co-trimoxazole exposure all modelled as stepwise constant covariates; ceftriaxone, ciprofloxacin and amoxicillin exposure included in a composite variable with decaying post-exposure effect, with $\gamma$ allowed to vary for each agent.

Weakly informative priors were used. A normally distributed prior centred at 0 with standard deviation 2 was used for all the $\alpha$ and $\beta$ parameters. A parameter value of 2 corresponds to a hazard ratio of 7.4; it would be surprising if any effect is greater than this so this could be argued to be a weakly informative prior. Normally distributed priors centred at 0 with standard deviation 0.2 were used for the $\mu$ and $\lambda$ parameters; in a model with no covariates, the inverse of these parameters are the mean times that an individual would remain in the colonised or uncolonised states, respectively, so a value of 0.2 corresponds to a mean state occupancy time of 50 days. A normally distributed prior centred at 0 and with standard deviation 50 days was used for all $\gamma$ parameters.

The Stan code for the models is given in the appendix to this chapter. Four chains were run in each case, with a warmup of 500 iterations and run for 1000 iterations in total. Convergence was assessed using the diagnostics described above. Stan v2.19 was used to sample from the posterior, accessed via Rstan v2.19.2, and run on the Wellcome Sanger Institute computing cluster under Linux Red Hat v7.6, running R v3.5.3, and gcc v6.3.0 C++ compiler. Four cores (one per MCMC chain) and 3GB of memory per model fit were used. Posterior samples were brought to my local machine (MacBook Pro running mac OS Mojave 10.14.5) and further analyses undertaken with R3.6.0.

### Assessing goodness of fit

Model goodness of fit was assessed in two ways; first, by graphical posterior predictive checks: comparing predicted total number of ESBL-E positive samples to the actual number across the three arms. This was done by using the posterior parameter estimates for each MCMC draw (after discarding warmup samples) to generate a predicted probability of the ESBL-E positive state for each data point, then sampling from a Bernoulli distribution to convert to predicted state occupancy. Each data point therefore had 2000 predictions for state occupancy, one for each posterior draw. These were plotted as kernel density plots against actual state occupancy, stratified by arm, to visualise the goodness of fit of the model, and to compare between models. 

Second, models were compared using leave-one-out cross validation, as implemented in the _loo_ v2.1.0 package in R[@Vehtari2017]. This estimates the out-of sample predictive ability of the model by estimating a quantity called the expected log pointwise predictive density ($ELPD$) essentially the log of the likelihood for a new, unseen dataset conditional on the current data. This quantity is estimated using leave-one-out cross validation to produce and estimate of the $ELPD$, hereafter referred to as $ELPD_{loo}$. The standard error of $ELPD_{loo}$ for a model is also calculated and so two models can be compared by comparing the $ELPD_{loo}$ difference and standard error; if the difference is greater than twice the standard error (i.e. a 95% confidence interval, assuming normality) we can be confident that one model would be expected to have greater out-of-sample predictive ability than the other[@Vehtari2017]. Because this technique estimates out-of-sample predictive ability it naturally incorporates a penalty for including multiple parameters and hence overfitting, as an overfit model would be expected to have worse out of sample predictive ability and hence lower $ELPD_{loo}$. 

### Exploring differences in carriage dynamics by bacterial species and _E. coli_ genotype

The models fit as described above predict whether a participant will be colonised with any ESBL producing organism at a given time point, but this classification obscures a lot of complexity. A participant can be colonised with different ESBL- producing species (largely _Eschericha coli_ or _Klebsiella pneumoniae_), and different clones of those species containing different ESBL genes on different mobile genetic elements (MGEs). It may be that there is heterogeneity in carriage dynamics across these different levels of the system. To address this hypothesis,  the best fitting model identified from the four described above was refit but the "colonised" state modified to either consider the species level or to use the whole genome sequence data presented in Chapters 6 and 7. The analysis in Chapter 7 suggests that the element most conserved within participants is the bacterial clone-ESBL contig combination, where the bacterial clone clusters were defined with the hierarchical BAPS algorithm and the ESBL-contig clusters defined with the cd-hit algorithm, as described in Chapter 7. The hierBAPS cluster-contig cluster pairs are coded as follows in this chapter: a.ESBLgene.b where a is the ID number of the level 2 hierBAPS cluster, and ESBLgene.b is the number of the contig cluster for a given ESBL gene, and for the rest of the chapter for brevity each unique hierBAPS cluster-contig cluster will be referred to as an _E. coli_ genotype. All _E. coli_ genotypes which were identified in more than 15 samples - 6 in total - were included and so the models were refit defining the colonised state as the presence of, respectively, ESBL _E.coli_ , _K. pneumoniae_ or one of the six included hierBAPS cluster-contig cluster pairs. The parameters for these models were compared with each other and with the original ESBL model.

### Simulations from the posterior

Finally, in order to better understand the relative role of antimicrobial exposure and hospitalisation in driving ESBL-E carriage, I conducted simulations with these exposures set at varying levels. The probability of ESBL colonisation as a function of time was calculated by solving the equations \@ref(eq:8a) and \@ref(eq:8b) using the R package _deSolve_ v1.2.4[@Soetaert2010], for each of the 2000 posterior parameter estimates from the posterior and assuming a 50% initial probability of ESBL colonisation. This yielded a distribution of carriage probability at each time point which was summarised using the median and 95% confidence intervals and plotted against time for varying covariate values: days of hospitalisation was varied from zero to twenty in steps of five, as was antimicrobial exposure, and each simulation repeated both with and without CPT.

## Results

### The effect of antibacterials and hospitalisation on ESBL-E carriage

First, I fit the four models with three specific aims: 

1. To identify the model that provides the best trade off between predictive ability and the computational cost to fit;

2. To explore the relative effects of hospitalisation versus antimicrobial exposure on ESBL-E carriage by assessing the posterior parameter values of these models; 

3. To assess support in the data for a post-antibacterial effect on ESBL-E carriage that persists once antibacterial therapy is stopped. 

For these models, the colonised state was defined as at least one ESBL producing organism of any species identified in a sample, and uncolonised as no ESBL producer identified. After excluding participants with only one sample, there were 993 pairs of samples in 363 participants remaining that contributed data to the analysis. All four models converged within the 1000 iterations; $\hat{R}$ was less than 1.1 for all parameters and all traceplots showed good mixing of chains. There were no divergences of the NUTS MCMC sampler in any of the models. There was a computational cost to increasing the number of parameters, as would be expected from the increase in dimensionality of the posterior: model one took 3.5 hours to fit, model two 13.7 hours, model three 17.1 hours and model four 33.4 hours. 

The parameter estimates for the models are shown in Figure \@ref(fig:ESBL-mod-param-est). There were significant correlations between some posterior parameters (see Figure \@ref(fig:pairs-mod2) in the chapter appendix for pairwise plots for model 2 as an example): particularly $\lambda$ and $\mu$, and the $\alpha$ and $\beta$ parameters. This is not necessarily problematic in that it is not necessarily a source of bias, but can make it difficult for some MCMC algorithms (e.g. Metropolis-Hastings) to adequately sample from the posterior[@Gelman]. Nevertheless, the diagnostics suggest that the Stan NUTS sampler had no problems.

The effect of hospitalisation is consistent across all models; in most models, the 95% credible intervals for both $\alpha$ and $\beta$ for hospitalisation do not cross zero and are positive, suggesting that the hazard ratio of hospitalisation on both the rate of acquisition and loss of ESBL-E is very likely to be greater than one, and the effect of hospitalisation is to increase both the rate of acquisition and loss of ESBL-E. The estimated effect sizes are consistent across the models though, as expected, uncertainty in the estimate increases as more parameters are added to the model. 

The effect of antibacterial exposure is also reasonably consistent across the models; the parameter $\alpha$ is negative in all cases, and often the 95% credible intervals do not cross zero, suggesting that the hazard ratio of antimicrobial exposure is likely to be less than zero. The effect sizes are similar in all cases, for all agents (including TB therapy), whether antibacterial exposure is considered as an aggregate variable or as individual agents; though in the extreme case where agents are all considered individually (Model 4, Figure \@ref(fig:ESBL-mod-param-est)D) the uncertainty in the estimates makes it difficult to draw any firm conclusions. This suggests that all the considered antibacterial agents act, with broadly similar effect size, to prolong ESBL-E carriage by reducing the rate of loss. No $\beta$ parameter (the log hazard ratio of ESBL-E acquisition) has 95% credible intervals that do not cross zero, consistent with antibacterial exposure having no or limited effect on ESBL-E acquisition.

The relative predictive ability of the four models were assessed in two ways: first, the predicted proportion of ESBL-E positive samples were plotted by sampling from the posterior (Figure \@ref(fig:ESBL-mod-ppc)); second, the pairwise $ELPD_{loo}$ differences (and standard errors in the differences) between all models calculated (Table \@ref(tab:ESBL-loo)). All models predicted ESBL-E carriage reasonably poorly for arm two and three participants, but better for arm one (Figure \@ref(fig:ESBL-mod-ppc)). The addition of a post-antibiotic effect improved model fit (seen by comparing model 1 to model 2 graphically in Figure \@ref(fig:ESBL-mod-ppc) and by an $ELPD_{loo}$ difference of more than two standard errors in Table \@ref(tab:ESBL-loo)) but models two, three and four, had similar fit despite the increase in number of parameters from seven in model two to seventeen parameters in model four. Model two therefore provides a good balance between computational tractability, interpretation and predictive ability; the parameter estimates for this model, expressed as hazard ratios for $\alpha$ and $\beta$, the mean time in state for $\lambda$ and $\mu$ and half life of post-antibacterial effect for $\gamma$ are shown in Table \@ref(tab:mod2-params). The significant $ELPD_{loo}$ difference between model 1 and 2 provides strong support for a post-antibiotic effect of antimicrobial exposure.

```{r ESBL-mod-param-est, echo = F, warning = F, message = F,fig.scap="Parameter estimates from Markov models", out.extra='', fig.cap = "Parameter estimates from increasingly complex Markov models to predict ESBL carriage. Black lines are 95\\% and red lines 80\\% credible intervals. A: Model 1 includes stepwise constant covariates only, animicrobial exposure (abx) and hospitalisation (hosp). $\\lambda$ is the baseline hazard and $\\beta$ the log hazard ratio of ESBL-E acquisition, $\\mu$ the baseline hazard and $\\alpha$ the log hazard ratio of ESBL-E loss. B: Model 2 adds a post-exposure effect of antimicrobial exposure, parameterised by $\\gamma$ as described in the text. C: Model 3 adds stepwise constant covariates for TB therapy (tb) and cotrimoxazole (cotr) with all other antimicrobial exposure captured in the abx variable, which has a post exposure effect as before. D: Model 4 seperates the effect of antimicrobial exposure into the component agents, with post exposure effects for all except cotrimoxazole and TB therapy.  In most models 95\\% credible intervals of $\\alpha$[hosp] and $\\beta$[hosp] do not cross zero and are positive, suggesting that hospitaliation acts to both increase rate of ESBL-E acquisition and loss; for antimicrobial exposure, on the other hand, only the 95\\% for antimicrobial $\\alpha$ values consistently do not cross zero, and are negative, suggesting that the effect of antimicrobial exposure is to reduce the rate of ESBL-E loss. It is also clear that adding parameters to the model increases the uncertainty in the estimates (e.g. compare model 2, B, to model 4, D).",  fig.height = 10, fig.width=8, out.height = '70%', fig.align = 'center'}


stan.df <- merge(stan.df, select(enroll, pid, arm), all.x = TRUE)

fit_mod1 <- readRDS("chapter_9/stan_models/model_1/stanfit_m1.rds")
fit_mod2 <- readRDS("chapter_9/stan_models/model_2/stanfit_m2.rds")
fit_mod3 <- readRDS("chapter_9/stan_models/model_3/stanfit_m3.rds")
fit_mod4 <- readRDS("chapter_9/stan_models/model_4/stanfit_m4.rds")


##mod 1

plot(fit_mod1, pars = c("ab_alpha0", "ab_beta0", "hosp_alpha1", "hosp_beta1")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("hosp_beta1", "hosp_alpha1","ab_beta0", "ab_alpha0" ), labels = c('hosp_beta1' =  expression(beta~"[hosp]"), 'hosp_alpha1' =  expression(alpha~"[hosp]"), 'ab_beta0' =  expression(beta~"[abx]"), 'ab_alpha0' =  expression(alpha~"[abx]"))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(-3,5))  -> a.mod1

plot(fit_mod1, pars = c("lambda", "mu")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
  coord_cartesian(xlim = c(0,0.4))-> b.mod1 

ggarrange(a.mod1, b.mod1, NULL, ncol = 3, nrow = 1, labels = c("A", NA, NA), widths = c(1.5,1,1)) -> m1.plot

plot(fit_mod2, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("betas[2]", "alphas[2]","betas[1]", "alphas[1]" ), labels = c('betas[2]' =  expression(beta~"[hosp]"), 'alphas[2]' =  expression(alpha~"[hosp]"), 'betas[1]' =  expression(beta~"[abx]"), 'alphas[1]' =  expression(alpha~"[abx]"))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(-3,5)) -> a.mod2

plot(fit_mod2, pars = c("lambda", "mu")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(0,0.4))-> b.mod2  

plot(fit_mod2, pars = c("gammas")) + 
  theme_bw() + 
  scale_y_discrete(limits = c("gammas[1]"), labels = c('gammas[1]' = expression(gamma~"[abx]"))) + theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
  coord_cartesian(xlim = c(0,250))-> c.mod2  

 ggarrange(a.mod2, b.mod2, c.mod2, ncol = 3, nrow = 1, labels = c("B", NA, NA), widths = c(1.5,1,1)) -> m2.plot
 
 # mod 3
 
 plot(fit_mod3, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]",
                         "alphas[3]", "betas[3]", "alphas[4]", "betas[4]")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + 
   scale_y_discrete(limits = rev(c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", 
                                "alphas[3]", "betas[3]", "alphas[4]", "betas[4]")),
                    labels = c('betas[4]' =  expression(beta~"[hosp]"), 
                               'alphas[4]' =  expression(alpha~"[hosp]"),
                               'betas[3]' =  expression(beta~"[tb]"), 
                               'alphas[3]' =  expression(alpha~"[tb]"),
                               'betas[2]' =  expression(beta~"[cotr]"), 
                                'alphas[2]' =  expression(alpha~"[cotr]"),
                                'betas[1]' =  expression(beta~"[abx]"), 
                                'alphas[1]' =  expression(alpha~"[abx]"))
                    ) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) +
                      xlab("Parameter value") +
                      coord_cartesian(xlim = c(-3,5)) -> a.mod3 
 
 plot(fit_mod3, pars = c("lambda", "mu")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
   coord_cartesian(xlim = c(0,0.4))-> b.mod3  
 
 plot(fit_mod3, pars = c("gammas")) + 
   theme_bw() + 
   scale_y_discrete(limits = c("gammas[1]"), labels = c('gammas[1]' = expression(gamma~"[abx]"))) + theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
   coord_cartesian(xlim = c(0,250))-> c.mod3  
 
 ggarrange(a.mod3, b.mod3, c.mod3, ncol = 3, nrow = 1, labels = c("C", NA, NA), widths = c(1.5,1,1)) -> m3.plot
 
 # mod 4
 
 
 
 
 plot(fit_mod4, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]",
                         "alphas[3]", "betas[3]", "alphas[4]", "betas[4]",
                         "alphas[5]", "betas[5]", "alphas[6]", "betas[6]")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + 
   scale_y_discrete(limits = rev(c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", 
                                   "alphas[3]", "betas[3]", "alphas[4]", "betas[4]",
                                   "alphas[5]", "betas[5]", "alphas[6]", "betas[6]")),
                    labels = c('betas[6]' =  expression(beta~"[hosp]"), 
                               'alphas[6]' =  expression(alpha~"[hosp]"),
                               'betas[5]' =  expression(beta~"[tb]"), 
                               'alphas[5]' =  expression(alpha~"[tb]"),
                               'betas[4]' =  expression(beta~"[cotr]"), 
                               'alphas[4]' =  expression(alpha~"[cotr]"),
                               'betas[3]' =  expression(beta~"[amx]"), 
                               'alphas[3]' =  expression(alpha~"[amx]"),
                               'betas[2]' =  expression(beta~"[cip]"), 
                               'alphas[2]' =  expression(alpha~"[cip]"),
                               'betas[1]' =  expression(beta~"[cef]"), 
                               'alphas[1]' =  expression(alpha~"[cef]"))
   ) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) +
   xlab("Parameter value") +
   coord_cartesian(xlim = c(-3,5)) -> a.mod4
 
 plot(fit_mod4, pars = c("lambda", "mu")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
   coord_cartesian(xlim = c(0,0.4))-> b.mod4
 
 plot(fit_mod4, pars = c("gammas")) + 
   theme_bw() + 
   scale_y_discrete(limits = rev(c("gammas[1]", "gammas[2]", "gammas[3]")), 
                    labels = c('gammas[3]' = expression(gamma~"[amx]"), 
                               'gammas[2]' =  expression(gamma~"[cip]"),
                               'gammas[1]' =  expression(gamma~"[cef]") )) + 
   theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + 
   xlab("Parameter value") + 
   coord_cartesian(xlim = c(0,250)) -> c.mod4  
 
 ggarrange(a.mod4, b.mod4, c.mod4, ncol = 3, nrow = 1, labels = c("D", NA, NA), widths = c(1.5,1,1)) -> m4.plot
 
 
 
 ggarrange(m1.plot, m2.plot,m3.plot, m4.plot, ncol = 1, nrow = 4, heights = c(1,1,1.3, 1.8))



```

```{r ESBL-mod-ppc, echo = F, warning = F, message = F,fig.scap="Predicted proprtion of ESBL-E positive samples, stratified by arm.", out.extra='', fig.cap = "Posterior predictive checks: kernal density estimate, D, of predicted proprtion of ESBL-E positive samples, stratified by arm for Model 1 (A), Model 2 (B), Model 3 (C) and Model 4 (D), generated by sampling from a Bernoulli distribution using the predicted probability for each sample (n=993) for each draw from the posterior, excluding warmup draws (n = 2000). True proportion of ESBL-E positive samples are shown for each arm by dotted vertical line. In all cases, predictions are poor for arm 2 and 3 samples, but the addition of a post-antibacterial effect improves fit, especially in arm 1 participants: compare Model 1 (A) with stepwise constant covariates to Model 2 (B) with post-antibacterial effect. Models 2-3 (B-D) have similar predictions despite more parameters.",  fig.height = 6, fig.width=6,fig.align = 'center'}


log_lik_mod1 <- extract_log_lik(fit_mod1)
log_lik_mod1.df <- as.data.frame(t(log_lik_mod1))
log_lik_mod1.df$pid <- as.character(stan.df$pid)
log_lik_mod1.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod1.df<- merge(log_lik_mod1.df, select(enroll, pid, arm), all.x = T)
log_lik_mod1.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod1.df.long
exp(log_lik_mod1.df.long$value) ->  log_lik_mod1.df.long$pred_prob
log_lik_mod1.df.long$pred_prob[log_lik_mod1.df.long$actual_end_state == 0] <- 1 - log_lik_mod1.df.long$pred_prob[log_lik_mod1.df.long$actual_end_state == 0]
log_lik_mod1.df.long$pred_state <- map_int(log_lik_mod1.df.long$pred_prob, ~rbinom(1,1,.))


actuals <- stan.df %>%
  group_by(arm) %>% 
  dplyr::summarise(n.esbl = sum(ESBL_stop == 1),
                   n = length(ESBL_stop),
                   prop = n.esbl/n) %>%
  ungroup() %>%
  dplyr::mutate(arm = as.character(arm),
         arm = recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) 
  

predicted <- log_lik_mod1.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                            prop = n.esbl/n) 

predicted %>% 
  ungroup() %>% dplyr::mutate(arm = as.character(arm),
                       arm = dplyr::recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>%
ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed") +
  coord_cartesian(xlim = c(0.3, 0.7)) +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> a


##


log_lik_mod2 <- extract_log_lik(fit_mod2)
log_lik_mod2.df <- as.data.frame(t(log_lik_mod2))
log_lik_mod2.df$pid <- as.character(stan.df$pid)
log_lik_mod2.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod2.df<- merge(log_lik_mod2.df, select(enroll, pid, arm), all.x = T)
log_lik_mod2.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod2.df.long
exp(log_lik_mod2.df.long$value) ->  log_lik_mod2.df.long$pred_prob
log_lik_mod2.df.long$pred_prob[log_lik_mod2.df.long$actual_end_state == 0] <- 1 - log_lik_mod2.df.long$pred_prob[log_lik_mod2.df.long$actual_end_state == 0]
log_lik_mod2.df.long$pred_state <- map_int(log_lik_mod2.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m2 <- log_lik_mod2.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                               prop = n.esbl/n) 

predicted_m2 %>% 
  ungroup() %>% dplyr::mutate(arm = as.character(arm),
    arm = recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>%
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> b

log_lik_mod3 <- extract_log_lik(fit_mod3)
log_lik_mod3.df <- as.data.frame(t(log_lik_mod3))
log_lik_mod3.df$pid <- as.character(stan.df$pid)
log_lik_mod3.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod3.df<- merge(log_lik_mod3.df, select(enroll, pid, arm), all.x = T)
log_lik_mod3.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod3.df.long
exp(log_lik_mod3.df.long$value) ->  log_lik_mod3.df.long$pred_prob
log_lik_mod3.df.long$pred_prob[log_lik_mod3.df.long$actual_end_state == 0] <- 1 - log_lik_mod3.df.long$pred_prob[log_lik_mod3.df.long$actual_end_state == 0]
log_lik_mod3.df.long$pred_state <- map_int(log_lik_mod3.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m3 <- log_lik_mod3.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                                  prop = n.esbl/n) 

predicted_m3 %>% 
  ungroup() %>% dplyr::mutate(arm = as.character(arm),
                       arm = recode_factor(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>% 
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> c

##
### mod 4

log_lik_mod4 <- extract_log_lik(fit_mod4)
log_lik_mod4.df <- as.data.frame(t(log_lik_mod4))
log_lik_mod4.df$pid <- as.character(stan.df$pid)
log_lik_mod4.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod4.df<- merge(log_lik_mod4.df, select(enroll, pid, arm), all.x = T)
log_lik_mod4.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod4.df.long
exp(log_lik_mod4.df.long$value) ->  log_lik_mod4.df.long$pred_prob
log_lik_mod4.df.long$pred_prob[log_lik_mod4.df.long$actual_end_state == 0] <- 1 - log_lik_mod4.df.long$pred_prob[log_lik_mod4.df.long$actual_end_state == 0]
log_lik_mod4.df.long$pred_state <- map_int(log_lik_mod4.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m4 <- log_lik_mod4.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                                  prop = n.esbl/n) 

predicted_m4 %>% 
  ungroup() %>% dplyr::mutate(arm = as.character(arm),
                       arm = recode_factor(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>% 
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> d

ggarrange(a,b,c,d, ncol = 1,nrow = 4, labels = c("A", "B", "C", "D"),
          common.legend = TRUE, legend = "bottom")




```

```{r ESBL-loo, echo = F, warning = F, message = F}

ll_m1 <- extract_log_lik(fit_mod1, merge_chains = FALSE)

r_eff_m1 <- relative_eff(exp(ll_m1)) 

ll_m2 <- extract_log_lik(fit_mod2, merge_chains = FALSE)
r_eff_m2 <- relative_eff(exp(ll_m2)) 

ll_m3 <- extract_log_lik(fit_mod3, merge_chains = FALSE)
r_eff_m3 <- relative_eff(exp(ll_m3)) 

ll_m4 <- extract_log_lik(fit_mod4, merge_chains = FALSE)
r_eff_m4 <- relative_eff(exp(ll_m4)) 

loo_mod <- list()

loo_mod[[1]] <- loo(ll_m1, r_eff = r_eff_m1, cores = 2 )
loo_mod[[2]] <- loo(ll_m2, r_eff = r_eff_m2, cores = 2 )
loo_mod[[3]] <- loo(ll_m3, r_eff = r_eff_m3, cores = 2 )
loo_mod[[4]] <- loo(ll_m4, r_eff = r_eff_m4, cores = 2 )

loo_mat <- matrix(nrow = 4, ncol = 4)
for (r in 1:4) {
  for (c in 1:4) {
    loo_temp <- loo::compare(loo_mod[[r]], loo_mod[[c]]) 
    if (r <= c) {
    loo_mat[r,c] <- glue('{specify_decimal(loo_temp[[1]],1)} ({specify_decimal(loo_temp[[2]],1)})')
     }
  }
}

loo_mat <- as.data.frame(loo_mat, stringsAsFactors = FALSE )
names(loo_mat) <- c("Model 1", "Model 2", "Model 3", "Model 4")
rownames(loo_mat) <- c("Model 1", "Model 2", "Model 3", "Model 4")
loo_mat[is.na(loo_mat)] <- "-"

kable(loo_mat, "latex", booktabs = TRUE,
      row.names = TRUE, escape = TRUE,
      caption = "Estimates (and standard error) of pairwise expected log pointwise predictive density differences for all models ") %>% kable_styling(full_width = FALSE) %>%
  footnote(general = "Cells in table compare row model to column model. A positive number favours the model in the column. The standard error of the ELPD difference is given in brackets; if twice the standard error is less than the estimated ELPD difference then we can be confident that the column model has better out-of-sample predictive fit than the row model. All models have better fit than model 1 but models 2-4 all have similar fit." ,threeparttable = T, fixed_small_size = T)
```

```{r mod2-params, echo = F, warning = F, message = F}

summary(fit_mod2, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", "gammas", "lambda", "mu")) -> s
as.data.frame(s$summary) -> s

s$vars <- rownames(s)

s <- dplyr::select(s,vars, `2.5%`, `50%`, `97.5%`)
# scale
s[1:4,2:4] <- exp(s[1:4,2:4])
s[5,2:4] <- s[5,2:4] * log(2)
s[6:7, 2:4] <- 1/s[6:7, 2:4] 
s[6,2:4] <- rev(s[6,2:4])
s[7,2:4] <- rev(s[7,2:4])

s$stri <- glue('{specify_decimal(s$`50%`,2)} ({specify_decimal(s$`2.5%`,2)}-{specify_decimal(s$`97.5%`,2)}) ')
s$vars <- c("Hazard ratio for ESBL-E loss", "Hazard ratio for ESBL-E acquisition",
            "Hazard ratio for ESBL-E loss", "Hazard ratio for ESBL-E acquisition",
            "Half life (days)",
            "Uncolonised (days)", "Colonised (days)")

kable(dplyr::select(s, vars, stri), "latex", booktabs = TRUE,
      row.names = FALSE, escape = FALSE, col.names = c("Variable", "Value"),
      caption = "Parameter estimates (and 95\\% confidence intervals) from model 2") %>% kable_styling(full_width = FALSE) %>%
  pack_rows("Effect of Antibacterials", 1,2) %>%
  pack_rows("Effect of Hospitalisation", 3,4) %>%
 pack_rows("Post Antibacterial Effect", 5,5) %>%
  pack_rows("Mean time in state", 6,7) %>%
  footnote(general = "Hazard ratios are the exponential of the parameters $\\\\alpha$ and $\\\\beta$ in the model; half life is equal to log(2) multiplied by $\\\\gamma$; mean time in state assumes all other covariates are equal to zero and is then the reciprocal of $\\\\lambda$ or $\\\\mu$." ,threeparttable = T, fixed_small_size = T, escape = FALSE)


```

### Exploring bacterial species and genotype differences in carriage dynamics

Next, I explored the differences in carriage dynamics between ESBL-E species and _E. coli_ genotype, by refitting model 2 but considering the colonised/uncolonised states to be, in turn, presence or absence of _E. coli_, _K. pneumoniae_ or any of the top six most prevalent _E. coli_ genotypes (as defined by the combination of ESBL containing contig cluster and _E. coli_ hierBAPS cluster [Chapter 7]), and refitting the model for each one. All 993 within-participant sample-pair comparisons were used to fit the _E. coli_ and _K. pneumoniae_ models, but because sample collection continued after the sequenced _E. coli_ included here were shipped, all samples collected after this time were excluded from the genotype models. 585 samples from 251 participants were therefore included in the genotype models.

The parameter estimates for these eight models (alongside the original ESBL-E presence/absence model) are shown in Figure \@ref(fig:bact-gen-mod-params). In general, there was more uncertainty in the parameter estimates for the new models, as might be expected as there are fewer carriage events, and fewer samples in the case of the genotype models. The only significant parameter difference between the models was in the $\lambda$ parameter, the baseline hazard of state acquisition. The magnitude of the difference was large; for example the median (95% CI) $\lambda_{ESBL}$ estimate of 0.10 (0.07-0.15) is almost three orders of magnitude larger than the estimate of $\lambda_{6.CTXM.27}$, 0.002 (0.001- 0.003). These values would correspond to a mean (95% CI) time in the uncolonised state of 10 (6-14) days for the ESBL model versus 500 (333-1000) days for the genotype model, assuming all other covariates were zero. The hazard rate of state loss, $\mu$ was similar, however, meaning that the time in the colonised state is similar for the ESBL model, and for all the _E. coli_ genotype models.

```{r bact-gen-mod-params, echo = F, warning = F, message = F,fig.scap="Parameter estimates from models of bacterial species and genotype carriage", out.extra='', fig.cap = "Parameter estimates from two state models predicting species and \\textit{E. coli} genotype carriage, compared to original model, which predicted carriage of any ESBL-E. A: All parameters, showing that the only significant difference between the models is the parameter $\\lambda$ (the hazard of acquisition), with an order of magnitude difference between the hazard of ESBL acquisition versus the acqusition of a particular genotype. B: $\\lambda$ parameter only for genotype models, showing that the estimates are similar for each genotype. ",  fig.height = 10, fig.width=6,out.height = '70%',fig.align = 'center'}

mods.sum <- list()

m.esco.fit <- readRDS("chapter_9/stan_models/model_2_esco/stanfit_m2_esco.rds")


mods.sum[[1]] <- as.data.frame(summary(m.esco.fit, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[1]]$vars <- rownames(mods.sum[[1]])
mods.sum[[1]]$model <- "E. coli"
  
m.klpn.fit <- readRDS("chapter_9/stan_models/model_2_klpn/stanfit_m2_klpn.rds")

mods.sum[[2]] <- as.data.frame(summary(m.klpn.fit, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[2]]$vars <- rownames(mods.sum[[1]])
mods.sum[[2]]$model <- "K. Pneumoniae"

m.1.ctxm15.16 <- readRDS("chapter_9/stan_models/model_2_1_ctxm15_16/stanfit_m2_1_ctxm15_16.rds")

mods.sum[[3]] <- as.data.frame(summary(m.1.ctxm15.16, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[3]]$vars <- rownames(mods.sum[[1]])
mods.sum[[3]]$model <- "1.ctxm15.16"


m.6.ctxm15.27 <- readRDS("chapter_9/stan_models/model_2_6_ctxm27_1/stanfit_m2_6_ctxm27_1.rds")

mods.sum[[4]] <- as.data.frame(summary(m.6.ctxm15.27, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[4]]$vars <- rownames(mods.sum[[1]])
mods.sum[[4]]$model <- "6.ctxm15.27"

m.8.ctxm15.27 <- readRDS("chapter_9/stan_models/model_2_8_ctxm27_1/stanfit_m2_8_ctxm27_1.rds")

mods.sum[[5]] <- as.data.frame(summary(m.8.ctxm15.27, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[5]]$vars <- rownames(mods.sum[[1]])
mods.sum[[5]]$model <- "8.ctxm15.27"

m.9.ctxm15.62 <- readRDS("chapter_9/stan_models/model_2_9_ctxm15_62/stanfit_m2_9_ctxm15_62.rds")

mods.sum[[6]] <- as.data.frame(summary(m.9.ctxm15.62, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[6]]$vars <- rownames(mods.sum[[1]])
mods.sum[[6]]$model <- "9.ctxm15.62"

m.23.ctxm15.57 <- readRDS("chapter_9/stan_models/model_2_23_ctxm15_57/stanfit_m2_23_ctxm15_57.rds")

mods.sum[[7]] <- as.data.frame(summary(m.23.ctxm15.57, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[7]]$vars <- rownames(mods.sum[[1]])
mods.sum[[7]]$model <- "23.ctxm15.57"

m.39.ctxm15.57 <- readRDS("chapter_9/stan_models/model_2_39_ctxm15_22/stanfit_m2_39_ctxm15_22.rds")

mods.sum[[8]] <- as.data.frame(summary(m.39.ctxm15.57, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[8]]$vars <- rownames(mods.sum[[1]])
mods.sum[[8]]$model <- "39.ctxm15.57"

fit_mod2 <- readRDS("chapter_9/stan_models/model_2/stanfit_m2.rds")

mods.sum[[9]] <- as.data.frame(summary(fit_mod2, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[9]]$vars <- rownames(mods.sum[[1]])
mods.sum[[9]]$model <- "ESBL"


mods.sum <- do.call(rbind, mods.sum)

mods.sum$model<- factor(mods.sum$model, levels = rev(c("ESBL", "E. coli",
                                                   "K. Pneumoniae",
                                                   grep("ctxm", unique(mods.sum$model), 
                                                        value = TRUE))))

mods.sum$vars <- recode_factor(mods.sum$vars,
                               `mu` = "mu",
                               `lambda` = "lambda",
                               `alphas[1]` = "alpha[abx]",
                               `alphas[2]` = "alpha[hosp]",
                               `betas[1]` = "beta[abx]",
                               `betas[2]` = "beta[hosp]",
                               `gammas[1]` = "gamma"
                               )
mods.sum %>% #filter(grepl("ctxm", model) | model == "ESBL_mod2") %>%
ggplot(aes(model, `50%`, ymin = `2.5%`, ymax = `97.5%`)) +
  geom_point() + geom_errorbar(width = 0) + theme_bw() + coord_flip() + facet_wrap(~vars, scales = "free_x", ncol = 2) +
  ylab("Parameter value") +
  xlab("Model") +
  theme(panel.spacing.x = unit(1, "lines")) -> p1

mods.sum %>% filter(grepl("ctxm", model), vars %in% c("lambda")) %>%
  ggplot(aes(model, `50%`, ymin = `2.5%`, ymax = `97.5%`)) +
  geom_point() + geom_errorbar(width = 0) + theme_bw() + coord_flip() + facet_wrap(~vars, scales = "free_x", ncol = 2) +
  ylab("Parameter value") +
  xlab("Model") +
  theme(panel.spacing.x = unit(1, "lines")) -> p2

ggarrange(p1,ggarrange(NULL,p2,NULL, widths = c(0.4,1,0.4), 
                       ncol = 3, nrow = 1, labels = c(NA,"B", NA)),
          ncol = 1, nrow = 2, heights = c(4,1), labels = c("A",NA))


```

### Simulation of different antibacterial and hospitalisation scenarios

Finally, to better understand the relative roles of antimicrobial exposure and hospitalisation in driving ESBL-E carriage, I simulated the probability of ESBL-E colonisation as antibacterial and hospital exposure changed from 0 to 20 days, assuming a 50% baseline probability of ESBL-E colonisation (Figure \@ref(fig:ESBL-simul)) and both with and without cotrimoxazole preventative therapy. Model 2 was used for these simulations. Hospitalisation seems to rapidly increase carriage probability and antimicrobial exposure produces a slower rise. Most striking, however, is that the effect of both exposures simultaneously causes a rapid increase in ESBL-E colonisation probability as well as prolonged decay to baseline probability: by the end of the 100 day simulation period in those simulations with both hospital and antibacterial exposure, most probabilities have not yet returned to baseline levels. Shorter course lengths of antibacterials seemed to have similar effects to longer courses. In the model used for the simulations (model two), the effect of all antibacterials (including CPT) is equal and so CPT seems to be the primary driver of an increased long-term carriage probability. TB therapy is also included in the composite "antibacterial" variable, so these conclusions would be equally valid for TB therapy.

```{r ESBL-simul, echo = F, warning = F, message = F,fig.scap= "Simulations of different antibacterial and hospitalisation scenarios", out.extra='', fig.cap = "Simulations of different antibacterial and hospitalisation scenarios. CPT = Cotrimoxazole preventative therapy. Plots show estimated probability of being in the ESBL+ state for given covariate values as a function of time, assuming a baseline 50\\% probability of ESBL-E colonisation. Antimicrobial exposure ranges across columns from 0 to 20 days, and hospitalisation across rows from 0 to 20 days. Hospitaliation causes a more rapid increase in probability than antimicrobial exposure, wheras antimicrobial exposure in the form of CPT is the primary deteriminent of increased long-term carriage probability. However, there is a synergistic effect of hospitalisation and antimicrobial exposure that results in rapid rise in colonisation probability and prolonged decay.",  fig.height = 8, fig.width=10,,fig.align = 'center'}

outsum <- read.csv("chapter_9/simulations.csv", stringsAsFactors = FALSE)

outsum$hosp_days_str <- factor(outsum$hosp_days_str, levels = unique(outsum$hosp_days_str[order(outsum$hosp_days)]))
outsum$abx_days_str <- factor(outsum$abx_days_str, levels = unique(outsum$abx_days_str[order(outsum$abx_days)]))

ggplot(outsum, aes(time, median, ymin = lq, ymax = uq, group = abx_cpt, linetype = as.factor(abx_cpt))) +
  geom_line() + geom_ribbon(alpha = 0.2, color = NA) + facet_grid(hosp_days_str ~ abx_days_str) + theme_bw() + theme(legend.title = element_blank(), panel.spacing = unit(1, "line")) + scale_linetype_manual(values = c("dotted", "solid")) + xlab("Time (days") + ylab("Pr(ESBL)")


```


## Discussion

In this chapter, I have extended the continuous-time Markov models available in the _msm_ package in R to incorporate true time-varying covariates (rather than stepwise constant). I have fitted them to the data presented in Chapter 5 using a Bayesian framework and a differential equation solver in the probabilistic programming language Stan. From these fitted models, it is possible to draw several conclusions.

First, the class of models that I present are feasible to fit in a reasonable amount of time with modest computational requirements, and are very flexible. The models were largely fit overnight on the WSI cluster with four cores and 3GB RAM. These are not particularly onerous requirements, and the times to fit would be expected to be similar on a desktop machine. The parametrisation of the model is extremely flexible; I chose an exponential form of a post-antibacterial effect but any functional form could be used, simply by replacing the function that generates the covariate values, $x(t)$ in Stan model. If a function can be written down, it can be fitted in this framework with minimal effort. This provides, for example, the opportunity to explore _in silico_ different hypotheses as to the ways in which antimicrobial exposure drives ESBL-E carriage, by exploring the functional form of the antimicrobial exposure covariate that best fits the data.
 
Second, the values of the parameter estimates and the simulations from the ESBL models allow an insight into the drivers of ESBL-E colonisation in Malawian adults, and suggests areas to target for interventions. Hospitalisation acts to increase both ESBL-E acquisition and loss, the net result of which is a rapid increase in the probability of ESBL-E colonisation following admission. Antimicrobial exposure acts to reduce the rate of ESBL-E loss and thus prolong carriage, but it simultaneous hospitalisation and antimicrobial exposure have a synergistic effect to produce the observed rapid increase in ESBL-E carriage prevalence seen in antibacterial exposed inpatients. The crude unadjusted analysis suggested that antimicrobial exposure alone was driving ESBL carriage; in fact, these models show that both hospitalisation and antimicrobial exposure act in synergy.

Whether these associations represent causal relationships and the mechanisms of any relationships are not addressed by the models, but causal associations are certainly biologically plausible. The hospital environment at QECH is such that cleaning is difficult, hand washing facilities for staff, participants and guardians are lacking, wards are crowded with participants close together, and one toilet is shared between around 60 patients, all of which potentially facilitate the acquisition of ESBL-E. The level of granularity of the models is such that the relative contributions of person-to-person transmission or transmission from the hospital environment or toilet facilities is not clear, and as it stands hospitalisation is used as an aggregate proxy for all of these putative transmission routes. 

The genomics data (Chapter 6) perhaps provides additional insight. There is no one hospital clone and in terms of _E. coli_ diversity at least, the hospital is largely an extension of the community. Given the number of adult admissions to QECH per year - around 15,000[@Lewis2003], this is perhaps not surprising: if each adult admission is cared for by two guardians then ~5% of the population of Blantyre -  800,000 at the 2018 census - is passing through QECH yearly. Given this, there is likely a frequent influx of ESBL-E clones from the community, which could, given the genomic data, suggest simple patient-to-patient transmission is the main route of ESBL-E acquisition; however, the hospital association of _E. coli_ ST410 implies a hospital reservoir of some sort. Further studies are needed to clearly understand transmission dynamics of AMR-bacteria within the hospital setting in Malawi, which could inform infection prevention and control (IPC) interventions. Evidence based IPC interventions which can be deployed in low-resource settings are urgently needed and, given the rates of hospital exposure in Blantyre, could potentially have a significant impact on the prevalence of ESBL-E there. 

Strategies to mitigate against the effect of antimicrobials on ESBL-E carriage are also needed. The data presented here support a post-exposure effect of antibacterials on prolonging ESBL-E carriage duration, such that short courses of antimicrobials seem to have a similar effect to longer courses in hospitalised participants. This finding may be contingent on the parametrisation of the post-antibiotic effect, and requires further exploration, but could have significant implications for antimicrobial stewardship. In this model framework, two days of antibacterial therapy to ten inpatients would results in more participant-days carriage of ESBL-E than twenty days of antibacterial therapy to one patient - as seen from the simulations presented in Figure \@ref(fig:ESBL-simul) - despite the same number of defined daily doses being used in total. This would suggest that antimicrobial stewardship interventions to avoid unnecessary antibacterials altogether would be more effective than those limiting antibacterial course lengths by e.g. review of blood culture results at 48 hours. The post-antibacterial effect has a lengthy half life of 44 days (95% credible interval 15-98 days), much longer than the time by which most antimicrobials will have been excreted from the body. Such a prolonged effect is biologically plausible, however even short courses of antimicrobials are known to profoundly alter the composition of the gut microbiota[@Palleja2018; @Francino2016], which could certainly alter ESBL-E carriage dynamics[@Buffie2013]. Further studies of the role of the microbiota in colonisation resistance to ESBL-E could shed light on the mechanisms of the post-antibacterial effect I demonstrate here, and pave the way for microbiota-modulating therapies to mitigate against it.

The role of CPT in driving long-term ESBL-E carriage is likely significant, and it appears to be a major determinant of long-term ESBL-E colonisation. Again, this is perhaps not surprising given that cotrimoxazole exposure dwarfs exposure to all other antimicrobials combined in the cohort, and that cotrimoxazole resistance genes are near-ubiquitous in the sequenced ESBL _E. coli_ isolates. It is not possible to say from the short read sequence data but cotrimoxaole resistance determinants could be collocated with ESBL resistance determinants, which would explain an apparent selection pressure for ESBL-E carriage from CPT. CPT has been shown to have significant mortality benefits in people living with HIV[@WorldHealthOrganisation2016], and lifelong CPT is mandated by WHO guidelines for all people living with HIV in areas with high malaria or bacterial infection prevalence, including Malawi[@MinistryofHealth.GovernmentofMalawi2016; @WorldHealthOrganisation2016]. Given an estimated adult Malawian HIV prevalence of 9.6%[UNAIDS], CPT is likely therefore a major driver of ESBL-E carriage in Malawi. The risk of driving AMR with CPT needs to be balanced against its benefits, and may be possible that in the era of high ART coverage, reducing malaria incidence and growing Gram-negative resistance that these risks begin to outweigh the benefits. The exact mechanism by which CPT confers a reduced mortality risk - whether it acts primarily to prevent opportunistic infections, bacterial infections or malaria - remains controversial. A recent RCT in Uganda carried out in 2012[@Anywaine2018] showed that a strategy of stopping CPT once the CD4 cell count is persistently above 250 cells $\mu L^{-1}$ is associated with more CPT-preventable infections, including malaria and pneumonia, but no difference in mortality (1.7% vs 1.8% over 12 months). Results are awaited of the TSCQ trial (ClinicalTrials.gov identifier NCT01650558), which has assessed the effect of mortality of CPT versus chloroquine malaria prophylaxis in Malawian HIV-infected adults, based on the hypothesis that in malaria-endemic areas the mortality benefit of CPT is primarily driven by its antimalarial properties. Given the findings here, a chloroquine based prophylaxis strategy could significantly impact ESBL-E carriage prevalence (and hence, possibly, infections) in Malawi and would be very attractive from this perspective if non inferior to CPT in mortality endpoints. 

Finally, using WGS as a high resolution typing tool allows very granular insight into ESBL-E carriage at the genotype level. Within the limitations of reasonably uncertain parameter estimates due to small numbers, all parameters for genotype carriage models were the same as the general ESBL carriage model, with the exception of $\lambda$. This indicates that the rate of acquisition of a given _E. coli_ genotype is two to three orders of magnitude lower then the overall rate of ESBL acquisition, in turn suggesting that apparent continual ESBL-E carriage in fact represents a much more frequent apparent acquisition of different ESBL-E genotypes. This could represent true acquisition or some other dynamic shift in the relative abundance of ESBL producing _E. coli_ in the microbiota over time. This analysis is, however, hampered by the fact that only one colony pick at each time point was sequenced and hence the true distribution of _E. coli_ genotypes at a given time point is unknown. 

### Limitations

There are several limitations to the analysis presented here. First, despite a reasonable number of data points, the parameter estimates from these models have moderate uncertainty. Some of this may be consequent on the model structure: with strongly correlated parameters, the data may be consistent with a wide range of paired parameter values. Even those parameter values whose 95% credible intervals cross zero (e.g. the hazard ratio of antibacterial exposure on ESBL-E acquisition in model 2) largely incorporate a clinically meaningful effect size, and so care must be taken not to interpret a lack of certainty of a significant effect as a lack of effect. Uncertainty in parameter estimates increases as more parameters are added, meaning that understanding the relative effects of different antibacterial agents on ESBL-E carriage is not possible, and in most models antibacterials are considered as an aggregate variable. _A priori_, different antibacterial agents would not be expected to have the same effect on ESBL-E carriage dynamics, but here they are considered together. There is some support for this strategy from the fact that the estimated effect sizes of ceftriaxone, ciprofloxacin and amoxicillin (the most commonly administered antibacterials apart from CPT and TB therapy) are similar when considered individually and in aggregate, but uncertainty in these estimates warrants caution. The apparent effect of TB therapy is particularly surprising, given that the first-line combination of rifampicin, pyrizinamide, ethambutol and isoniazid would be expected to have a limited selection pressure for ESBL-E, and warrants further study. This could represent Gram-negative activity of rifampicin or confounding by CPT, given that the majority of participants receiving TB therapy also receive CPT. 

In addition, despite fitting well to participants from arm 1 of the study (those with sepsis), the models fit poorly to arm 2 (antimicrobial unexposed participants) and arm 3 (community members). The reasons for this are not clear, but it strongly suggests that there are covariates that are not included in the model that differentiate the arms of the study in some way. If these covariates are also associated with the exposures of interest (hospitalisation and antibacterial exposure) then this is a potential source of bias from confounding.

These models assume perfect test characteristics, such that the measurement of ESBL-E status (or species or genotype, depending on the model) perfectly represents the true state. This is unlikely to be the case in practice, and there is also likely to be differential test characteristics between the different stool testing methods (stool or rectal swab culture) used. This may have introduced bias to the parameter estimates and simulations. Expanding the model to incorporate imperfect tests - a hidden Markov model - could address this limitation, as well as provide estimates of test sensitivity and specificity. Conceptually this is straightforward; the underlying "true" state is modelled, the likelihood for a given participant (Equation \@ref(eq:3)) becomes the sum over all possible underlying paths through the system and parameters are added for the sensitivity and specificity of the tests used. This will, however, increase computational costs: if a participant has ESBL-E status measured at $n$ time points then calculating the likelihood required summing over all $2^n$ possible combinations of states, rather than just one as in the models presented here.

Generalising the model to allow states to be hidden or censored would also address a serious limitation of the genotype models. In these models, the absence of a particular genotype from a sample is interpreted as true absence, but the true situation is more complex. If no ESBL at all is cultured then we can be confident that a given genotype is absent, within the confines of the test sensitivity. However, if _E. coli_ were cultured at any time point, then only one colony pick was taken forward for sequencing, meaning that it is possible that any number of other genotypes were present in the sample but not picked and sequenced and therefore identified. Data on within-participant gut mucosal ESBL-E diversity are sparse, but those data that are available suggest that it may be considerable[@Stoesser2015], and so these models should be considered as merely exploratory. Expanding the model to allow states to be censored (i.e. for the true underlying state to remain unknown for a given measurement) is equivalent to the changes that would be necessary to incorporate hidden Markov models, and would address these problems.

## Conclusion and further work

In conclusion, I have developed and fit time-inhomogeneous Markov models to the clinical longitudinal ESBL-E carriage data. The models are computationally tractable, extremely flexible, and provide insight into the drivers of ESBL-E carriage in Blantyre. Though both hospitalisation and antibacterial exposure significantly affect the probability of ESBL-E carriage independently, they appear to act synergistically together to drive colonisation. Antibacterial exposure seems to have an effect that persists long after most antibacterials would be expected to be excreted from the body; the models provide no data on the mechanism of this but one hypothesis would be that it is mediated by changed in the microbiota. Short courses of antibacterials seem to produce a similar effect to longer courses, which may have implications for antibacterial stewardship interventions. Co-trimoxazole preventative therapy may be one of the major drivers of long-term ESBL-E carriage in Malawian adults and this should be considered in developing international and national guidelines on its use.

These conclusions suggest a direction for future work. The models must be expanded to incorporate censored states to allow the fitting of hidden Markov models and to account for the single colony pick sampling method which was used. This, in conjunction with whole genome sequencing of the remainder of the isolates from the study will allow unbiased models to be fitted to understand carriage at the level of the genotype. Finally, shotgun metagenomic sequencing of stored extracted stool DNA from the participants in this study will a) define the total diversity of ESBL genes within each sample and b) will allow an analysis to identify microbiota associations of ESBL-E colonisation and the effect of antibacterial exposure. This will allow testing of the hypothesis that the post-antibacterial effect I have identified is mediated via the microbiota.

## Appendix

The Stan code for the fitted models is below; the stepwise-constant covariate model is presented first, and all other models were fitted with the second model. Pairwise posterior parameter estimates for model two (to demonstrate strong parameter correlations) are also shown below; see text for details. 

```{r pairs-mod2, echo = FALSE,warning= FALSE, message=FALSE,fig.scap='ESBL-E carriage model pairwise posterior parameter estimates', out.extra='', fig.cap = 'ESBL-E carriage model pairwise posterior parameter estimates, showing correlations between alpha and beta for a given covariate, and lambda and mu. These results are for model 2 to predict ESBL-E probability - see text for details. Alpha[1] and beta[1] are the coefficients for the composite antibacterial exposure variable, alpha[2] and beta[2] for hospitalisation, lambda the rate of ESBL-E loss, mu the rate of ESBL-E acquisition, and gamma the scaled (by log(2)) half life of the post-antibacterial effect.', fig.height=8, fig.width=8,fig.align = 'center' }

pairs(fit_mod2, pars = c("alphas[1]", "betas[1]","alphas[2]", "betas[2]", "gammas", "mu", "lambda"))


```

\clearpage

```{stan stancode-gammamod, output.var = "time-var-mod", eval = FALSE, tidy = TRUE }
// Stan final model incorporating varying numbers of covariates
// Optional gamma decay
// Uses rk45 ODE solver
// Joe Lewis July 2019

// to call this model from Rstan, pass it the following data

// N: integer = number of rows of data, each row consisting of two ESBL
// observations for one patient

// n_covs: integer vector of length 3 = [number of
// nontimevarying covariates,
// number of stepwise constant covariates, 
// number of exp decay covariates ]

// covs_type: integer vector of length(number of covariates) = 
// each position encodes the type of variable
// in the order they are presented in covs_mat:
    // 3 = time varying with exponential decay of effect
    // 2 = time varying with piecewise constant
    // 1 = nontimevarying
    // All the exp decay variables must always go first
    
// cov_mat: real matrix of start and stop times of 
// covariates 3*(with number of covariate) cols
// Each covariate needs three columns, in this order
    // start_time: time that covariate started
    // stop time: time that covariate stopped. 
    // If there is no covariate exposure in this row, code as -999
    // prev_stop time: if covariate has exp. decay, this is 
    // the previous stop time (before current row e.g. -10)
    // If no previous exposure, code as 999
    // If non time varying exposure, code as 999 = present, -999 absent
    
// start state: real vector of length2 = start state in 
// format (ESBL-, ESBL+) ie esbl positive coded as 
// [0,1] and ESBL negative coded as [1,0]

// end state: integer length 1, final state.

// this will also generate and save log-likelihoods to do model comparison with loo.

functions {
      
// Time varying covariate value calculation
// Needs to be passed a 1d array of covariates 
// each 3 entries are  (cov_start_time, cov_end_time, prev_cov_end_time)
// prev_cov_end_time is coded as
// t of prev cov end time if has been exposure, pos no if not
// Needs to return a matrix with n_cov rows and 1 column
// to act on the alphas and betas of the model
  
      
// n_covs is an array with integer for each cov
// 1 = not tme varying and coded with prev time- present if > 0 
// and absent of < 0
// 2 = time varying but no decay; prev time is ignored
// 3 = time varying with decay. If there is no 
// exposure in this block, set stop_time to < 0

real[] return_time_varying_coefs_exp_flat(
  real[] cov_mat_passed,
  real t1,
  int[] n_covs_passed,
  real[] gamma_passed
      ) {
        real out_vars[size(n_covs_passed)];
        int s;
        int f;
        int p;
         
        for (n in 1:size(n_covs_passed)) {
          s = 1 + ((n-1)*3);
          f = s + 1;  
          p = f + 1;
               // for each row in cov matrix (ie each covariate)
          if (n_covs_passed[n] == 3) {
               // gamma decay 
            if (cov_mat_passed[f] > 0) {   //if there is exposure this block
                if (t1 <= cov_mat_passed[f] && t1 >= cov_mat_passed[s]) {
                    // if exposure is happening now
                    // set value to 1
                out_vars[n] = 1;
                } else if (t1 > cov_mat_passed[f]) {
                    // otherwise if there is exposure in this block
                    // and this covariate is set to have a decaying effect
                    // and time is after it has stopped
                    // set value to decay from stop time
                  out_vars[n] = exp((t1-cov_mat_passed[f])/(-1*gamma_passed[n]));
                 } else if (t1 < cov_mat_passed[s] && cov_mat_passed[p] < 0) {
                   // otherwise, if time is before start time
                    // and there is previous exposure
                    // set value to decay from previous time
                  out_vars[n] = exp((t1-cov_mat_passed[p])/(-1*gamma_passed[n]));
                  } else {
                     //  otherwise set to 0
                out_vars[n] = 0; 
                   }
               } else {   // if there is no exposure in this block
                   if (cov_mat_passed[p] < 0) {    // if there is previous exposure
                     out_vars[n] = exp((t1-cov_mat_passed[p])/(-1*gamma_passed[n]));
                   } else {
                     out_vars[n] = 0;
                   }
                }
               
              } else if (n_covs_passed[n] == 2) {
                
               if (t1 <= cov_mat_passed[f] && t1 >= cov_mat_passed[s]) {
                    // if exposure is happening now
                    // set value to 1
               out_vars[n] = 1;
               } else {
               out_vars[n] = 0; 
               }
              } else if (n_covs_passed[n] == 1) {
                if (cov_mat_passed[p] > 0) {
                   out_vars[n] = 1;
                } else {
                   out_vars[n] = 0;
                }
              }
         }  // end of for loop
         return out_vars;
         } // end of fn
         
      // function to return lambda(t) and mu(t) 
      // this should take a vector of length n_cov of time
      // varying values of the covariates of the betas 
      // (from the time varying coef fn)
      // and two vectors of length n_cov of parameters
      //the alphas (that act on mu)
      // and the betas (that act on lambda)
      // and return a vect or of length two for the 
      // values of lamba(t) and mu(t)
      
    //  real[] return_time_var_transition_hazard(
   //      real
    //  ) 
      
      // differential state equation
      
      real[] twostateODE2_flat(real t,   // time
      real[] y,                     // state
      real[] theta,                 // parameters
      real[] x_r,                   //data
      int[] x_i) {                 // data
         
         // y is state as [p0,p1]
         // theta defined as 
         // [ lambda, mu, gamma0, ... gamman,
         //  alpha0, alpha1, ... alphan,
         //  beta0 ... betan ]
         // where n is number of covariatese 
         // data x_r is 1d array of covariates, 3 for each covariate
         // x_i is array of covariate type as
          // [number of non-timedep var,
          //number of timedep nongamma var, 
          //number of gamma var,
          // then an integer for each cov: 
          //1 (non timedep),2(nongamm) or 3(gamma)]
         
         real dydt[2];
         real coefs[size(x_i[])-3];  //vector of coefs
         real alphaz[size(x_i[])-3]; // vector of alphas
         real betaz[size(x_i[])-3]; // vector of betas
         real gammaz[x_i[3]];
         real lambda_pr;
         real mu_pr;
         real lambda0;
         real mu0;
         lambda0 = theta[1];
         mu0 = theta[2];
         gammaz =   theta[3:(2+ x_i[3])];
         alphaz = theta[(3+ x_i[3]):(3+x_i[3] + x_i[1] + x_i[2] + x_i[3] -1)] ;
         betaz = theta[(3+x_i[3] + x_i[1] + x_i[2] + x_i[3]):(2+x_i[3] + 2*(x_i[1] + x_i[2] + x_i[3]))];
         coefs = return_time_varying_coefs_exp_flat(x_r, t, x_i[4:size(x_i)], gammaz);
         lambda_pr = lambda0*exp(dot_product(coefs, betaz));
         mu_pr = mu0*exp(dot_product(coefs, alphaz));
         
         dydt[1] = -y[1]*lambda_pr + y[2]*mu_pr;
         dydt[2] = y[1]*lambda_pr - y[2]*mu_pr;   
         return dydt;
      } // end of function 
}       // end of block

  data {
      int < lower = 1 > N; // Number of rows of data
      int <lower = 0> n_covs[3];  //[nontimevary, timevarynogamma, timevarygamma]
      int covs_type[sum(n_covs)]; // integer for each cov to define type
      real t[N];                  // end time
      real cov_mat[N,sum(n_covs[])*3]; // array of covariates, 3 rows for each 
      real start_state[N,2]; // start state (at t=0) in form [p0,p1]
      int end_state[N];   // end state (at t) as integer
      }

      transformed data {
         int x_i_pass[3 + sum(n_covs)];
         x_i_pass[] = append_array(n_covs[], covs_type[]);
      }
      
      parameters {
      real < lower = 0 > lambda;
      real < lower = 0 > mu;
      real <lower = 0> gammas[n_covs[3]];
      real alphas[sum(n_covs[])];
      real betas[sum(n_covs[])];
      }
      
      transformed parameters {
      real theta[2 + 2*(sum(n_covs)) + n_covs[3]];
      theta[1] = lambda;
      theta[2] = mu;
      theta[3:(2+ n_covs[3])] = gammas[];
      theta[(3+ n_covs[3]):(3+n_covs[3] + sum(n_covs) -1)] = alphas[];
      theta[(3+n_covs[3] + sum(n_covs)):(2+n_covs[3] + 2*(sum(n_covs)))] = betas[];
      }
      
 model {
      real temp[1,2];
      lambda ~ normal(0,0.2);
      mu ~ normal(0,0.2);
      alphas ~ normal(0,2);
      betas~ normal(0,2);
      gammas ~ normal(0,100);

      for (n in 1:N) {

       temp = integrate_ode_rk45(twostateODE2_flat, 
       start_state[n], 
       0, t[n:n],
       theta[], 
       cov_mat[n], 
       x_i_pass[], 1e-6,1e-6,1e6);
     
       if (end_state[n] == 1) {
          target += log(temp[1,2]);
       } else {
         target += log(temp[1,1]);
       }
      }
}
      
generated quantities {
   // needed for loo
    vector[N] log_lik;
    real temp[1,2];
    for (n in 1:N) {
      temp = integrate_ode_rk45(twostateODE2_flat,
      start_state[n],
      0, 
      t[n:n],
      theta[], 
      cov_mat[n],
      x_i_pass[], 
      1e-6,1e-6,1e6);
      if (end_state[n] == 1) {
        log_lik[n] = log(temp[1,2]);
      } else {
       log_lik[n] = log(temp[1,1]);
      }
    }
}  
```

\clearpage

```{stan stancode-stepwise,  output.var = "stepwise-cont-mod", eval= FALSE, tidy= TRUE,}
// Stan model for msm style interval censored model, stepwise constant covariates
      
      functions {
      
      // Differential state equations for solving    
      
      real[] twostateODE(real t,        // time
      real[] y,      // state
      real[] theta,  // parameters
      real[] x_r,    // data (real)
      int[] x_i) {   // data (integer) 
      
      real dydt[2]; 
      real lambda;
      real mu;
      real ab_alpha0;
      real ab_beta0;
      real hosp_alpha1;
      real hosp_beta1;
      
      real lambda_beta_sum;
      real mu_alpha_sum;
      
      lambda= theta[1] ;
      mu = theta[2];
      ab_alpha0 = theta[3];
      ab_beta0 = theta[4];
      hosp_alpha1 = theta[5];
      hosp_beta1 = theta[6];
      
      lambda_beta_sum = 0;
      mu_alpha_sum = 0;
      
      // first coef, abx, start x_r[1] and end time x_r[2]
      
      if (x_r[1] == 999) {
      // dont do anything, there is nothing for this covariate
      } else if (t <= x_r[2] && t >= x_r[1]) {
      lambda_beta_sum = lambda_beta_sum + ab_beta0;
      mu_alpha_sum = mu_alpha_sum + ab_alpha0;
      }      
      
      // second coef coef, abx, start x_r[3] and end time x_r[4]
      
      if (x_r[3] == 999) {
      // don't do anything, there is nothing for this covariate
      } else if (t <= x_r[4] && t >= x_r[3]) {
      lambda_beta_sum = lambda_beta_sum + hosp_beta1;
      mu_alpha_sum = mu_alpha_sum + hosp_alpha1;
      }      
      
      
      dydt[1] = -y[1]*lambda*exp(lambda_beta_sum) + y[2]*mu*exp(mu_alpha_sum);
      dydt[2] = y[1]*lambda*exp(lambda_beta_sum) - y[2]*mu*exp(mu_alpha_sum);     
      
      
      return dydt;
      } 
      }
      
      data {
      int < lower = 1 > N; // Sample size
      real t[N]; // end time
      real start_state[N,2]; // start state (at t_start) in form [p0,p1]
      int end_state[N];   // end state (at t) as integer
      real covariates[N,4]; // covariate start and end times 
                          // (as ab_start, ab_end, hosp_start, hosp_end)
      }
      
      transformed data {
      // real x_r[0];
      int x_i[0];
      
      }
      
      parameters {
      real < lower = 0 > lambda;
      real < lower = 0 > mu;
      real ab_alpha0;
      real ab_beta0;
      real hosp_alpha1;
      real hosp_beta1;
      // real < lower = 0 > gamma;
      }
      
      transformed parameters {
      real theta[6];
      theta[1] = lambda;
      theta[2] = mu;
      theta[3] = ab_alpha0;
      theta[4] = ab_beta0;
      theta[5] = hosp_alpha1;
      theta[6] = hosp_beta1;
      
      }
      
      model {
      real temp[1,2];
      lambda ~ normal(0,0.2);
      mu ~ normal(0,0.2);
      ab_alpha0 ~ normal(0,2);
      ab_beta0 ~ normal(0,2);
      hosp_alpha1 ~ normal(0,2);
      hosp_beta1 ~ normal(0,2);
      //gamma ~ normal(20,20);
      for (n in 1:N) {
      temp = integrate_ode_rk45(twostateODE,
      start_state[n], 
      0,
      t[n:n],
      theta, 
      covariates[n],
      x_i,
      1E-6,1E-6, 1E6);
      
      if (end_state[n] == 1) {
      target += log(temp[1,2]);
      } else {
      target += log(temp[1,1]);
      }
      }
      }
      
      generated quantities {
      vector[N] log_lik;
      real temp[1,2];
      for (n in 1:N) {
      temp = integrate_ode_rk45(twostateODE, 
      start_state[n],
      0, t[n:n],
      theta, 
      covariates[n], 
      x_i, 
      1E-6,1E-6, 1E6);
      
      if (end_state[n] == 1) {
      log_lik[n] = log(temp[1,2]);
      } else {
      log_lik[n] = log(temp[1,1]);
      }
      }
      }  
      
      // The posterior predictive distribution
```

