# Continuous time Markov models to understand ESBL-E carriage dynamics

\chaptermark{Modelling ESBL-E carriage}

```{r ch8-setup, include = F}
library(plyr)
library(tidyverse)
library(reshape2)
library(rstan)
library(loo)
library(kableExtra)
library(glue)
library(deSolve)

source("other_scripts/load_metadata.R")

source("final_cleaning_scripts/load_and_clean_followup_and_enroll_labelled.R")
source("other_scripts/summary_table_functions.R")
source("final_cleaning_scripts/make_composite_hivstatus_variable.R")
source("final_cleaning_scripts/load_and_clean_hourly.R")
source("final_cleaning_scripts/load_and_clean_bloods.R")
#source("final_cleaning_scripts/load_and_clean_aetiol.R")
#source("final_cleaning_scripts/load_and_clean_hourly.R")
source("final_cleaning_scripts/load_and_clean_upto72.R")
source("final_cleaning_scripts/load_and_clean_post72.R")
source("final_cleaning_scripts/load_and_clean_hosp_oc.R")
#source("final_cleaning_scripts/load_and_clean_time_to_ab.R")
#source("final_cleaning_scripts/load_and_clean_fluid_hr1_to_6.R")
source("other_scripts/stan_helpers/arrange_stan_df_functions.R")

# lims




#panel data helper functions
source("other_scripts/panel_data_helpers/expand_covariates.R")
source("other_scripts/panel_data_helpers/sort_out_tb_rx_on_discharge.R")
source("other_scripts/panel_data_helpers/shuffle_a_in_b2.R")
source("other_scripts/panel_data_helpers/strip_post_dropout_rows.R")
source("other_scripts/panel_data_helpers/extract_covariate_exposure.R")
source("other_scripts/panel_data_helpers/collapse_covariates.R")
source("other_scripts/panel_data_helpers/ditch_everything_after_first_1.R")
source("other_scripts/panel_data_helpers/mstate_helper_functions.R")
source("other_scripts/panel_data_helpers/splice_ESBL2.R")

names(enroll)[names(enroll) == "data_date"] <- "enroll_date"
followup <- merge(followup, select(enroll, pid, arm, enroll_date), all.x = T)
followup$t <- followup$data_date - followup$enroll_date

# and load lims
source("final_cleaning_scripts/load_and_clean_lims.R")

stan.df <- read.csv("data/stan_df.csv", stringsAsFactors = F)
# ans stan df

specify_decimal <- function(x, k) trimws(format(round(x, k), nsmall=k))
```
## Chapter Overview

whatevs bru

## Introduction and chapter aims

## Methods

### Developing the time-inhomogeneous Markov models

In the broadest sense when constructing a model, our aim is to estimate the most likely values of the parameters of the model, $\theta$, given the data we have, $x$. The starting point for estimating likely parameter values, given a choice of model, is usually the _likelihood_: this is the probability of the data, given a set of parameter values. In standard probability notation, this is written as $P(x | \theta)$. In fact, this is not the quantity we are interested in; we would like to know $P(\theta | x )$: the probability of the parameter values, given the data. Both frequentist and Bayesian modelling approaches provide methods to estimate this quantity, but the starting point for both is the likelihood, $P(x| \theta)$, because it is usally much more straightforward to derive an expression for $P(x | \theta)$ rather than $P(\theta | x )$. I will here derive a general likelihood for a two state intermittentently observed process; in order to use this likelihood, it is necessary to make some assumptions about the data generating process. I have chosen to use a Markov model, and I will then derive the likelihood for this model, describe how covariates will be incorporated , describe how the model was fit - the process taking us  from the likelihood to the most likely parameter values - and finally how goodness of was fit assessed.

### General form of likelihood

First, I derive a general expression for the likelihood of a two-state intermittently observed process without making any assumptions about the model structure or functional form. Assume we have $N$ participants with any givenparticipant $n$ in a state $S_{n}(t)$ at time $t$: either ESBL-E colonised ($S_{n}(t) = 1$) or uncolonised ($S_{n}(t) = 1$). For each participant $n$ we have a number of measurements of $S_{n}(t)$ at a number of time points. The number of measurements varies for each participant, and can be denoted by $j_{n}$, making the time of measurements $t^n_{j_{n}}$ for patricipant $n$; and so for participant $n$ we know the  $j_{n}$ values $S_{n}(t^n_{j_{n}})$. 

To arrive at the likelihood for these observations, consider first the simplest situation that we have: the measurements of ESBL status at two time points, $t_{A}$ and $t_{B}$ for a single participant, $n$. The likelihood we wish to calculate, in words, is the probability of the participant being in the second observed state at time $t_{B}$, given they were in the first state at $t_{A}$ and given the parameters of the model, $\theta$. Or, mathematically:

\begin{equation} 
P(S_{n}(t_{B}) | S_{n}(t_{A}), \theta)
(\#eq:1)
\end{equation} 

Assuming all the observations are independent, the probability of  all of the states we have observed for this participant is the product of all the probabilities of the individual states:

\begin{equation} 
\prod^{j_{n}}_{k =2} P(S_{n}(t^n_{k}) | S_{n}(t^n_{k-1}), \theta )
(\#eq:2)
\end{equation} 

And the probability of observing the data we have is then simply the product of the probability of all the individual transitions:

\begin{equation} 
\prod^N_{n=1}\prod^{j_{n}}_{k =2} P(S_{n}(t^n_{k}) | S_{n}(t^n_{k-1}), \theta )
(\#eq:3)
\end{equation} 

This is the quantity that we wish to calculate: the likelihood for the observed data, $P(x|\theta)$. Note that the sum over states for an individual in equation \@ref(eq:3) starts from 2; if a participant has only one available sample then this does not provide any information about transition probabilities, and must be excluded from the analysis.

### Markov model likelihood

In order to calculate the likelihood, we need to make some assumptions about the data generating process. In this case, I have chosen to use a Markov model. Markov models are defined by instantanous transition probabilities, analogous to the hazard of death in a survival model, which is a simple two-state Markov system. Unlike a survival model (where it is not possible to move from the death state to alive), a general Markov model is defined by a transition hazard from each state to each other state in the system. These are traditionally expressed as a Q matrix of instantaneous transition intensities (assuming a two-state system):

\begin{equation} 
\mathbf{Q}(t) = \begin{pmatrix} q_{00}(t) & q_{01}(t) \\\ q_{10}(t) & q_{11}(t) \end{pmatrix}
(\#eq:4)
\end{equation} 

Where $q_{ij}$ represents the instantaneous transition intensity from state $i$ to state $j$. The rows of the Q-matrix must sum to 1 (every participant has to be in one state or another), so if we define the hazard of ESBL-E acquisition to be $\lambda$ and the hazard of ESBL-E loss to be $\mu$ (\@ref(fig:ESBL-twostate-diag)), the Q-matrix becomes, in our case:

\begin{equation} 
\mathbf{Q}(t) =  \begin{pmatrix} -\lambda(t) & \lambda(t) \\\ \mu(t)  & -\mu(t) \end{pmatrix} 
(\#eq:5)
\end{equation} 


However, we are not interested in the Q-matrix _per se_ but rather the probability $p_{ij}$ of starting in state $i$ at time 0 and being in state $j$ at time $t$; this can be written in matrix notation as $\mathbf{P}(t)$ and is related to $\mathbf{Q}(t)$ by the differential equations:

\begin{equation} 
\displaystyle \frac{d\mathbf{P}(t)}{dt} =  \mathbf{Q}(t) . \mathbf{P}(t)
(\#eq:6)
\end{equation} 

Where $\mathbf{Q}(t) . \mathbf{P}(t)$ is the matrix product of $\mathbf{Q}(t)$ and $\mathbf{P}(t)$. In order to eva,uate $\mathbf{P}(t)$, therefore we need to solve this system of differential equations. However, there are limited situations in which these equations have analytic solutions. If the system has time constant or piecewise constant Q matrix the matrix exponential is a solution:

\begin{equation} 
\mathbf{P}(t) = e^{\mathbf{Q}}
(\#eq:7)
\end{equation} 

However, there is no reason to suspect particularly that the effect of covariates on ESBL-E carriage (e.g. antimicrobials) would be stepwise constant and so a more flexible model is needed. For general time-varying transition intensities, there is no analytic solution to the above equations. However, all is not lost: we can express the likelihood in terms of the differential equations defined by the equations above  and solve them numerically in order to calculate the likelihood. The matrix notation aboev can be simplified, assuming that the system starts in state 1 or 0:

\begin{equation} 
\displaystyle \frac{dP_0(t)}{dt} = -\lambda(t) P_0(t) + \mu(t) P_1(t)
(\#eq:8a)
\end{equation} 
\begin{equation} 
\displaystyle \frac{dP_1(t)}{dt} = \lambda(t) P_0(t) - \mu(t) P_1(t)
(\#eq:8b)
\end{equation} 

Where $P_i(t)$ is the probability of being in state $i$ at time t. Numerical ordinary differential equation (ODE) solvers can quickly solve these equations to calculate, for example, $P(S_{n}(t_{B}) | S_{n}(t_{A}), \theta)$ from the simplest example above: the probability that a participant $n$ at time $t_{B}$ is in a given state, given that they were in state $S_{n}(t_{A})$ at time $t_{A}$, and given the parameters $\theta$. This calculation can be completed for all meaurements and participants, resulting in the likelihood of the system, $P(x | \theta)$. 

In order to use this model for inference, two questions must be addressed: first, how to incorporate time-varying covariates; and second, how to practically fit the model. I address each of these questions below.

```{r ESBL-twostate-diag, echo = F, warning = F, message = F,fig.scap='Two state ESBL-E model', out.extra='', fig.cap = 'Two state ESBL-E model showing instanteneous hazard of ESBL-E acquisition ($\\lambda$) or loss ($\\mu$).', out.height = '20%',fig.align = 'center'}


knitr::include_graphics("chapter_9/state_diag.png")
```

### Incorporating covariates: a proportional hazard model

I have chosen to incorporate covariates using a proportional-hazards model, following both Marshall and Jones[ref] and the _msm_ package in R. In this model the transmission intensities become:
\begin{align} 
\lambda(t) = \lambda_{0}\exp{(\beta_0x_{0}(t) + \beta_1x_{1}(t) + ...\beta_mx_{m}(t))} \\
\mu(t) = \mu_{0}\exp{(\alpha_0x_{0}(t) + \alpha_1x_{1}(t) + ...\alpha_mx_{m}(t))}
(\#eq:9b)
\end{align} 

Where the $x_{k}, k = 1,2...m$ are the $m$ time-varying covariates in the model and the coefficients $\alpha_{k}$ and $\beta_{k}$ are the coefficients of these covariates; these have a straightforward interpretation in that the exponential, $e^{\alpha_{k}}$ or$e^{\beta_{k}}$ can be interpreted as a hazard ratio, as per a simple surivival model. 

An assumption then needs to be made about the functional form of $x_{m}$. In a stepwise-constant covariate model in which an exposure occurs between $t_{A}$ and $t_{B}$,  $x(t)$ would take the value 1 for all $t_{A} \le t \le t_{B}$t and 0 at other times, meaning that the effect of the exposure does not persist once it ceases. Though this may be plausible for some exposures, it seems possible that antimicrobial exposure (for example) might have a longer lasting effect or post-exposure effect; in order to explore this possibility, it is necessary to decide on a flexible, plausible, functional form that such an effect might take. I have decided to use an exponential function, such that:

\begin{equation}
x_{k}(t) = 
\begin{cases} 
0  & \text{if } t < t_{A}\\
1   & \text{if } t_{A} \le t \le t_{B}\\
\exp{\displaystyle \frac{-(t - t_{B})}{\gamma_{k}}} & \text{if } t > t_{B}\\
\end{cases}
(\#eq:10)
\end{equation}

Where the parameter $\gamma_{k}$ is a model parameter for each of the covariates, to be estimated from the data, and is related to the half life, $t^{k}_{\frac{1}{2}}$ of the decay of the effect of the exposure by:

\begin{equation}
t^k_{\frac{1}{2}} = \gamma_{k}\ln(2) \approx 0.69\gamma_{k}
(\#eq:11)
\end{equation}

From the definition of the half life of an exponential decay process. This parameterisation has the advantage that the data can fit the size of the parameters $\gamma_{k}$; if the data are more inkeeping with a stepwise effect of the covariates, then a small ($\ll 1$) $\gamma$ would approximate a step functon and this could be fit by the model. Alternatively a larger would result in the effect of the covariate persisting after exposure, but decaying over time. This allows us to test the hypothesis that antimicrobial exposure (for example) has an effect that persists once exposure finishes, by both the magnitude of the fitted $\gamma_{k}$, and comparing stepwise-constant covariate models to models incorporating the $\gamma_{k}$ parameters.

The parameters of the model all have the advantage of having a reasonably intuitive meaning: $\exp(\alpha)$ and $\exp(\beta)$ are the hazard ratio for ESBL-E loss and aquisition, respectively; the reciprocals of $\lambda$ and $\mu$ are the mean time in days spent in the uncolonised or colonised states, respectively; and $\ln(2)\gamma \approx 0.69\gamma$, as stated above, is the half life of the post-exposure effect.

### Building and fitting models 

The Bayesian probabablistic programming language _Stan_ incorporates an ordinary differential equation solver, and will allow the fitting of the model in a Bayesian framework. In this framework, Bayes' rule  allows us to estimate our probability distribution of interest, $P(\theta | x)$, called the _posterior_ in the Bayesian framework, a long as we provide a _prior_, encoding our prior beliefs about the values of the parameters as a probability distribuion for each parameter. Stan then uses the No-U-Turn Sampler  (NUTS) implementation of Markov-chain Monte-Carlo (MCMC) sampling to sample from the posterior to provide $P(\theta | x)$. It can be shown that, given infinite chain length, MCMC estimates are guaranteed to be unbiased samples from the posterior; when this occurs the chains have said to converged. Unfortunately there is no diagnostic test that guarantees convergence, rather tests that are necessary but not sufficent to ensure convergence: running multiple chains from different starting points with examination of traceplots to show within and between mixing of chains, and the $\hat{R}$ statistic, which measures mixing of the two halves of an MCMC chain. At convergence, $\hat{R}$ should be close to 1. In addition, divergences - failure in the NUTS sampler - can be indicative of difficult topography in the posterior at the area where the divergences occur, and suggest that parameter estimates may be biased, and are flagged by Stan. All of these tests were used to diagnose convergence.

Two decsisions must be made in order to fit the model: covariates must be chosen to include and priors specified. Models were built sequentially to predict ESBL-E status, starting from the simplest possible, then adding complexity:

* _Model 1:_ Composite antibacterial variable (includes all antibacterials) and hospitalisation variable as explanatory variables, both included with stepwise constant effect and no post exposure effect.

* _Model 2:_ As per model 1 except antibacterial exposure modelled with decaying post-exposure effect.

* _Model 3:_ Hospitalisation, TB therapy and co-trimoxazole exposure all modelled as stepwise constant covariates. All other antibacterials included in a composite variabe with decaying post-exposure effect.

* _Model 4:_ Hospitalisation, TB therapy and co-trimoxazole exposure all modelled as stepwise constant covariates; ceftriaxone, ciprofloxacin and amoxicillin exposure included in a composite variable with decaying post-exposure effect, with $\gamma$ allowed to vary for each agent.

Weakly informative priors were used. A normally distributed prior centered at 0 with standard deviation 2 was used for all the $\alpha$ and $\beta$ parameters. A parameter value of 2 corresponds to a hazard ratio of 7.4; it would be surprising if any effect is greater than this so this could be argued to be a weakly informative prior. Normally distributed priors centered at 0 with standard deviation 0.2 were used for the $\mu$ and $\lambda$ parameters; in a model with no covariates, the inverse of these parameters are the mean times that an individual would remain in the colonised or uncolonised states, respectively, so a value of 0.2 corresponds to a mean state occupancy time of 50 days. A normally distributed prior centred at 0 and with standard deviation 50 days was used for all $\gamma$ parameters.

The Stan code for the models is given in the appendix to this chapter. Four chains were run in each case, with a warmup of 500 iterations and run for 1000 iterations in total. Convergence was assessed using the diagnostics described above. Stan v2.19 was used to sample from the posterior, accessed via Rstan v2.19.2, and run on the Wellcome Sanger Institute computing cluster under Linux Red Hat v7.6, running R v3.5.3, and gcc v6.3.0 C++ compiler. Four cores and 3GB of memory per model fit were used. Posterior samples were brought to my local machine (MacBook pro running macOS Mojave 10.14.5) and further analyses undertaken with R3.6.0.

### Assessing goodness of fit

Model goodness of fit was assessed in two ways; first, by graphical posterior predictive checks: comparing predicted total number of ESBL-E positive samples to the actual number across the three arms. This was done by using the posterior parameter estimates for each MCMC draw (after disgarding warmup samples) to generate a predicted probability of the ESBL-E positive state for each data point, then sampling from a Bernoulli distribution to convert to predicted state occupancy. Each data point therefore had 2000 predictions for state occupancy, one for each posterior draw. These were plotted as kernal density plots against actual state occupancy, stratified by arm, to visualise the goodness of fit of the model, and to compare between models. 

Second, models were compared using leave-one-out cross validation, as implemented in the _loo_ v2.1.0 package in R. This estimates the out-of sample predictive ability of the model by estimating a quantity called the expected log pointwise predictive denisty ($ELPD$) essentially the log of the likelihood for a new, unseen dataset conditional on the current data. This quantity is estimated using leave-one-out cross validation to produce and estimate of the $ELPD$, hereafter referred to as $ELPD_{loo}$. The standard error of $ELPD_{loo}$ for a model is also calculated and so two models can be compared by comparing the $ELPD_{loo}$ difference and standard error; if the difference is greater than twice the standard error (i.e. a 95% confidence interval, assuming normality) we can be confident that one model would be expected to have greater out-of-sample predictive ability than the other. Because this technique estimates out-of-sample predictive ability it naturally incorporates a penalty for including multiple parameters and hence overfitting, as an overfit model would be expected to have worse out of sample predictive ability and hence lower $ELPD_{loo}$. 

### Exploring differences in carriage dynamics by bacterial species and _E. coli_ genotype

The models fit as described above predict whether a participant will be colonised with any ESBL producing organism at a given time point, but this classifcation obscures a lot of complexity. A participant can be colonised with different ESBL- prodcuing species (largely _Eschericha coli_ or _Klebsiella pneumoniae_), and different clones of those species containing different ESBL genes on different mobile genetic elements (MGEs). It may be that there is heterogeneity in carriage dynamics across these different levels of the system. To address this hypothesis,  the best fitting model identified from the four described above was refit but the "colonised" state modified to either consider the species level or to use the whole genome sequence data presented in Chapters 6 and 7 as a high-resolution typing system to track bacteria trhough he system. The analysis in Chapter 7 suggests that the element most conserved witin participants is the bacterial clone-ESBL contig combination, where the bacterial clone clusters were defined with the hierarchical BAPS algorithm and the ESBL-contig clusters defined with the cd-hit algorithm, as described in Chapter 7. The hierBAPS cluster-contig cluster pairs are coded as follows in this chapter: a.ESBLgene.b where a is the ID number of the level 2 hierBAPS cluster, and ESBLgene.b is the number of the contig cluster for a given ESBL gene, and for the rest of the chapter for brevity each unique hierBAPS cluster-contig cluster will be referred to as an _E. coli_ genotype. All _E. coli_ genotypes which were identified in more than 15 samples - 6 in total - were included and so the models were refit defining the colonised state as the presence of, respectively, ESBL _E.coli_ , _K. pneumoniae_ or one of the six included hierBAPS cluster-contig cluster pairs. The parameters for these models were compared with each other and with the original ESBL model.

### Simulations from the posterior

Finally, in order to better understand the relative role of antimicrobial exposure and hospitalisation in driving ESBL-E carriage, I conducted simulations with these exposures set at varying levels. The probability of ESBL colonistion as a function of time was calculated by solving the equations \@ref(eq:8a) and \@ref(eq:8b) using the R package _deSolve_ v1.2.4, for each of the 2000 posterior parameter estimates from the posterior and assuming a 50% initial probability of ESBL colonisation. This yielded a distribution of carriage probability at each time point which was summarised using the median and 95% confidence intervals and plotted against time for varying covariate values: days of hospitalisation was varied from one to twenty in steps of five, as was antimicrobial exposure, and each simulation repeated both with and without cotrimoxazole preventative therapy (CPT). 

## Results

### Exploring the effect of antibacterials and hospitalisation on ESBL-E carriage

First, I fit the four models with two aims: to identify the model that provides the best trade off between predictive ability and the computational cost to fit, and to explore the relative effects of hospitalisation versus antimicrobial exposure on ESBL-E carriage by assessing the posterior parameter values of these models. The colonised state was defined as at least one ESBL producing organism of any species identified in a sample, and uncolonised as no ESBL producer identified. After excluding participants with only one sample, there were 993 pairs of samples in 363 participants remaining that contributed data to the analysis. All four models converged within the 1000 iterations; $\hat{R}$ was less than 1.1 for all parameters and all traceplots showed good mixing of chains. There were no divergences of the NUTS MCMC sampler in any of the models. There was a computational cost to increasing the number of parameters, as would be expected from the increase in dimensionality of the posterior: model one took 3.5 hours to fit, model two 13.7 hours, model three 17.1 hours and model four 33.4 hours. 

The parameter estimates for the models are shown in Figure \@ref(fig:ESBL-mod-param-est). The effect of hospitalisation is consistent across all models; in most models, the 95% credible intervals for both $\alpha_{hospitalisation}$ and $\beta_{hospitalisation}$ do not cross zero and are positive, suggesting that the hazard ratio of hospitalisation on both the rate of acquisition and loss of ESBL-E is very likely to be greater than one, and the effect of hospitalisation is to increase both the rate of acquisition and loss of ESBL-E. The estimated effect sizes are consistent across the models though, as expected, uncertainty in the estimate increases as more parameters are addded to the model. 

The effect of antibacterial exposure is also reasonably consistent accross the models; the parameter $\alpha$ is negative in all cases, and often the 95% credible intervals do not cross zero, suggesting that the hazard ratio of antimicrobial exposure is likely to be less than zero. The effect sizes are similar in all cases, for all agents (incuding TB therapy), whether antibacterial exposure is considered as an aggregate variable or as individual agents; though in the extreme case where agents are all considered individually (Model 4, Figure \@ref(fig:ESBL-mod-param-est)D) the uncertainty in the estimates makes it difficult to draw any firm conclusions. This suggests that all the considered antibacterial agents act, with broadly similar effect size, to prolong ESBL-E carriage by reducing the rate of loss. No $\beta$ parameter (the log hazard ratio of ESBL-E acquisition) has 95% credible intervals that do not cross zero, consistent with antibacterial exposure have no or limited effect on ESBL-E acqusition.

The relative predictive ability of the four models were assessed in two ways: first, the predicted proportion of ESBL-E positive samples were plotted by sampling from the posterior (Figure \@ref(fig:ESBL-mod-ppc)); second, the pairwise $ELPD_{loo}$ differences (and standard errors in the differences) between all models calculated (Table \@ref(tab:ESBL-loo)). All models predicted ESBL-E carriage reasonably poorly for arm two and three participants, but better for arm one \@ref(fig:ESBL-mod-ppc)). The addition of a post-antibiotic effect improved model fit (seen by comparing model 1 to model 2) but models two, three and four, had similar fit despite the increase in number of parameters from seven in model two to seventeen parameters in model four. Model two therefore provides a good balance between computational tractability, interpretation and predictive ability; the parameter estimates for this model, expressed as hazard ratios for $\alpha$ and $\beta$, the mean time in state for $\lambda$ and $\mu$ and half life of post-antibacterial effect for $\gamma$ are shown in Table \@ref(tab:mod2-params).

```{r ESBL-mod-param-est, echo = F, warning = F, message = F,fig.scap="Parameter estimates from Markov models", out.extra='', fig.cap = "Parameter estimates from increasingly complex Markov models to predict ESBL carriage. Black lines are 95\\% and red lines 80\\% credible intervals. A: Model 1 includes stepwise constant covariates only, animicrobial exposure and hospitalisation. $\\lambda$ is the baseline hazard and $\\beta$ the log hazard ratio of ESBL-E acquisition, $\\mu$ the baseline hazard and $\\alpha$ the log hazard ratio of ESBL-E loss. B: Model 2 adds a post-exposure effect of antimicrobial exposure, parameterised by $\\gamma$ as described in the text. C: Model 3 adds stepwise constant covariates for TB therapy (tb) and cotrimoxazole (cotri) with all other antimicrobial exposure captured in the abx variable, which has a post exposure effect as before. D: Model 4 seperates the effect of antimicrobial exposure into the component agents, with post exposure effects for all except cotrimoxazole and TB therapy.  In most models 95\\% credible intervals of $\\alpha$[hosp] and $\\beta$[hosp] do not cross zero and are positive, suggesting that hospitaliation acts to both increase rate of ESBL-E acquisition and loss; for antimicrobial exposure, on the other hand, only the 95\\% for antimicrobial $\\alpha$ values consistently do not cross zero, and are negative, suggesting that the effect of antimicrobial exposure is to reduce the rate of ESBL-E loss. It is also clear that adding parameters to the model increases the uncertainty in the estimates (e.g. compare model 2, B, to model 4, D).",  fig.height = 10, fig.width=8, out.height = '70%', fig.align = 'center'}


stan.df <- merge(stan.df, select(enroll, pid, arm), all.x = TRUE)

fit_mod1 <- readRDS("chapter_9/stan_models/model_1/stanfit_m1.rds")
fit_mod2 <- readRDS("chapter_9/stan_models/model_2/stanfit_m2.rds")
fit_mod3 <- readRDS("chapter_9/stan_models/model_3/stanfit_m3.rds")
fit_mod4 <- readRDS("chapter_9/stan_models/model_4/stanfit_m4.rds")


##mod 1

plot(fit_mod1, pars = c("ab_alpha0", "ab_beta0", "hosp_alpha1", "hosp_beta1")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("hosp_beta1", "hosp_alpha1","ab_beta0", "ab_alpha0" ), labels = c('hosp_beta1' =  expression(beta~"[hosp]"), 'hosp_alpha1' =  expression(alpha~"[hosp]"), 'ab_beta0' =  expression(beta~"[abx]"), 'ab_alpha0' =  expression(alpha~"[abx]"))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(-3,5))  -> a.mod1

plot(fit_mod1, pars = c("lambda", "mu")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
  coord_cartesian(xlim = c(0,0.4))-> b.mod1 

ggarrange(a.mod1, b.mod1, NULL, ncol = 3, nrow = 1, labels = c("A", NA, NA), widths = c(1.5,1,1)) -> m1.plot

plot(fit_mod2, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("betas[2]", "alphas[2]","betas[1]", "alphas[1]" ), labels = c('betas[2]' =  expression(beta~"[hosp]"), 'alphas[2]' =  expression(alpha~"[hosp]"), 'betas[1]' =  expression(beta~"[abx]"), 'alphas[1]' =  expression(alpha~"[abx]"))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(-3,5)) -> a.mod2

plot(fit_mod2, pars = c("lambda", "mu")) + 
  theme_bw() +
  geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
  coord_cartesian(xlim = c(0,0.4))-> b.mod2  

plot(fit_mod2, pars = c("gammas")) + 
  theme_bw() + 
  scale_y_discrete(limits = c("gammas[1]"), labels = c('gammas[1]' = expression(gamma~"[abx]"))) + theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
  coord_cartesian(xlim = c(0,250))-> c.mod2  

 ggarrange(a.mod2, b.mod2, c.mod2, ncol = 3, nrow = 1, labels = c("B", NA, NA), widths = c(1.5,1,1)) -> m2.plot
 
 # mod 3
 
 plot(fit_mod3, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]",
                         "alphas[3]", "betas[3]", "alphas[4]", "betas[4]")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + 
   scale_y_discrete(limits = rev(c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", 
                                "alphas[3]", "betas[3]", "alphas[4]", "betas[4]")),
                    labels = c('betas[4]' =  expression(beta~"[hosp]"), 
                               'alphas[4]' =  expression(alpha~"[hosp]"),
                               'betas[3]' =  expression(beta~"[tb]"), 
                               'alphas[3]' =  expression(alpha~"[tb]"),
                               'betas[2]' =  expression(beta~"[cotr]"), 
                                'alphas[2]' =  expression(alpha~"[cotr]"),
                                'betas[1]' =  expression(beta~"[abx]"), 
                                'alphas[1]' =  expression(alpha~"[abx]"))
                    ) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) +
                      xlab("Parameter value") +
                      coord_cartesian(xlim = c(-3,5)) -> a.mod3 
 
 plot(fit_mod3, pars = c("lambda", "mu")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
   coord_cartesian(xlim = c(0,0.4))-> b.mod3  
 
 plot(fit_mod3, pars = c("gammas")) + 
   theme_bw() + 
   scale_y_discrete(limits = c("gammas[1]"), labels = c('gammas[1]' = expression(gamma~"[abx]"))) + theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + xlab("Parameter value") + 
   coord_cartesian(xlim = c(0,250))-> c.mod3  
 
 ggarrange(a.mod3, b.mod3, c.mod3, ncol = 3, nrow = 1, labels = c("C", NA, NA), widths = c(1.5,1,1)) -> m3.plot
 
 # mod 4
 
 
 
 
 plot(fit_mod4, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]",
                         "alphas[3]", "betas[3]", "alphas[4]", "betas[4]",
                         "alphas[5]", "betas[5]", "alphas[6]", "betas[6]")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + 
   scale_y_discrete(limits = rev(c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", 
                                   "alphas[3]", "betas[3]", "alphas[4]", "betas[4]",
                                   "alphas[5]", "betas[5]", "alphas[6]", "betas[6]")),
                    labels = c('betas[6]' =  expression(beta~"[hosp]"), 
                               'alphas[6]' =  expression(alpha~"[hosp]"),
                               'betas[5]' =  expression(beta~"[tb]"), 
                               'alphas[5]' =  expression(alpha~"[tb]"),
                               'betas[4]' =  expression(beta~"[cotr]"), 
                               'alphas[4]' =  expression(alpha~"[cotr]"),
                               'betas[3]' =  expression(beta~"[amx]"), 
                               'alphas[3]' =  expression(alpha~"[amx]"),
                               'betas[2]' =  expression(beta~"[cip]"), 
                               'alphas[2]' =  expression(alpha~"[cip]"),
                               'betas[1]' =  expression(beta~"[cef]"), 
                               'alphas[1]' =  expression(alpha~"[cef]"))
   ) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) +
   xlab("Parameter value") +
   coord_cartesian(xlim = c(-3,5)) -> a.mod4
 
 plot(fit_mod4, pars = c("lambda", "mu")) + 
   theme_bw() +
   geom_vline(xintercept = 0, linetype = "dashed") + scale_y_discrete(limits = c("lambda", "mu"), labels = c('lambda' =  expression(lambda), 'mu' =  expression(mu))) + theme(axis.title.y = element_blank(), axis.text.y = element_text(size = 14)) + xlab("Parameter value") +
   coord_cartesian(xlim = c(0,0.4))-> b.mod4
 
 plot(fit_mod4, pars = c("gammas")) + 
   theme_bw() + 
   scale_y_discrete(limits = rev(c("gammas[1]", "gammas[2]", "gammas[3]")), 
                    labels = c('gammas[3]' = expression(gamma~"[amx]"), 
                               'gammas[2]' =  expression(gamma~"[cip]"),
                               'gammas[1]' =  expression(gamma~"[cef]") )) + 
   theme(axis.title.y = element_blank(),axis.text.y = element_text(size = 14)) + 
   xlab("Parameter value") + 
   coord_cartesian(xlim = c(0,250)) -> c.mod4  
 
 ggarrange(a.mod4, b.mod4, c.mod4, ncol = 3, nrow = 1, labels = c("D", NA, NA), widths = c(1.5,1,1)) -> m4.plot
 
 
 
 ggarrange(m1.plot, m2.plot,m3.plot, m4.plot, ncol = 1, nrow = 4, heights = c(1,1,1.3, 1.8))



```

```{r ESBL-mod-ppc, echo = F, warning = F, message = F,fig.scap="Predicted proprtion of ESBL-E positive samples, stratified by arm.", out.extra='', fig.cap = "Posterior predictive checks: kernal density estimate, D, of predicted proprtion of ESBL-E positive samples, stratified by arm for Model 1 (A), Model 2 (B), Model 3 (C) and Model 4 (D), generated by sampling from a Bernoulli distribution using the predicted probability for each sample (n=993) for each draw from the posterior, excluding warmup draws (n = 2000). True proportion of ESBL-E positive samples are shown for each arm by dotted vertical line. In all cases, predictions are poor for arm 2 and 3 samples, but the addition of a post-antibacterial effect (quantified by $\\gamma$) improves fit, especially in arm 1 participants: compare Model 1 (A) with stepwise constant covariates to Model 2 (B) with post-antibacterial effect. Models 2-3 (B-D) have similar predictions despite more parameters.",  fig.height = 6, fig.width=6,fig.align = 'center'}


log_lik_mod1 <- extract_log_lik(fit_mod1)
log_lik_mod1.df <- as.data.frame(t(log_lik_mod1))
log_lik_mod1.df$pid <- as.character(stan.df$pid)
log_lik_mod1.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod1.df<- merge(log_lik_mod1.df, select(enroll, pid, arm), all.x = T)
log_lik_mod1.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod1.df.long
exp(log_lik_mod1.df.long$value) ->  log_lik_mod1.df.long$pred_prob
log_lik_mod1.df.long$pred_prob[log_lik_mod1.df.long$actual_end_state == 0] <- 1 - log_lik_mod1.df.long$pred_prob[log_lik_mod1.df.long$actual_end_state == 0]
log_lik_mod1.df.long$pred_state <- map_int(log_lik_mod1.df.long$pred_prob, ~rbinom(1,1,.))


actuals <- stan.df %>%
  group_by(arm) %>% 
  dplyr::summarise(n.esbl = sum(ESBL_stop == 1),
                   n = length(ESBL_stop),
                   prop = n.esbl/n) %>%
  ungroup() %>%
  mutate(arm = as.character(arm),
         arm = recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) 
  

predicted <- log_lik_mod1.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                            prop = n.esbl/n) 

predicted %>% 
  ungroup() %>% mutate(arm = as.character(arm),
                       arm = recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>%
ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed") +
  coord_cartesian(xlim = c(0.3, 0.7)) +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> a


##


log_lik_mod2 <- extract_log_lik(fit_mod2)
log_lik_mod2.df <- as.data.frame(t(log_lik_mod2))
log_lik_mod2.df$pid <- as.character(stan.df$pid)
log_lik_mod2.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod2.df<- merge(log_lik_mod2.df, select(enroll, pid, arm), all.x = T)
log_lik_mod2.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod2.df.long
exp(log_lik_mod2.df.long$value) ->  log_lik_mod2.df.long$pred_prob
log_lik_mod2.df.long$pred_prob[log_lik_mod2.df.long$actual_end_state == 0] <- 1 - log_lik_mod2.df.long$pred_prob[log_lik_mod2.df.long$actual_end_state == 0]
log_lik_mod2.df.long$pred_state <- map_int(log_lik_mod2.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m2 <- log_lik_mod2.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                               prop = n.esbl/n) 

predicted_m2 %>% 
  ungroup() %>% mutate(arm = as.character(arm),
    arm = recode(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>%
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> b

log_lik_mod3 <- extract_log_lik(fit_mod3)
log_lik_mod3.df <- as.data.frame(t(log_lik_mod3))
log_lik_mod3.df$pid <- as.character(stan.df$pid)
log_lik_mod3.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod3.df<- merge(log_lik_mod3.df, select(enroll, pid, arm), all.x = T)
log_lik_mod3.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod3.df.long
exp(log_lik_mod3.df.long$value) ->  log_lik_mod3.df.long$pred_prob
log_lik_mod3.df.long$pred_prob[log_lik_mod3.df.long$actual_end_state == 0] <- 1 - log_lik_mod3.df.long$pred_prob[log_lik_mod3.df.long$actual_end_state == 0]
log_lik_mod3.df.long$pred_state <- map_int(log_lik_mod3.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m3 <- log_lik_mod3.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                                  prop = n.esbl/n) 

predicted_m3 %>% 
  ungroup() %>% mutate(arm = as.character(arm),
                       arm = recode_factor(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>% 
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("D") +
  theme_bw() + theme(legend.title = element_blank())-> c

##
### mod 4

log_lik_mod4 <- extract_log_lik(fit_mod4)
log_lik_mod4.df <- as.data.frame(t(log_lik_mod4))
log_lik_mod4.df$pid <- as.character(stan.df$pid)
log_lik_mod4.df$actual_end_state <- stan.df$ESBL_stop
log_lik_mod4.df<- merge(log_lik_mod4.df, select(enroll, pid, arm), all.x = T)
log_lik_mod4.df %>% pivot_longer(-c(pid, actual_end_state, arm)) -> log_lik_mod4.df.long
exp(log_lik_mod4.df.long$value) ->  log_lik_mod4.df.long$pred_prob
log_lik_mod4.df.long$pred_prob[log_lik_mod4.df.long$actual_end_state == 0] <- 1 - log_lik_mod4.df.long$pred_prob[log_lik_mod4.df.long$actual_end_state == 0]
log_lik_mod4.df.long$pred_state <- map_int(log_lik_mod4.df.long$pred_prob, ~rbinom(1,1,.))

predicted_m4 <- log_lik_mod4.df.long %>% group_by(arm, name) %>% dplyr::summarise(n.esbl = sum(pred_state == 1),                                                         n = length(pred_state),
                                                                                  prop = n.esbl/n) 

predicted_m4 %>% 
  ungroup() %>% mutate(arm = as.character(arm),
                       arm = recode_factor(arm, `1` = "Arm 1", `2` = "Arm 2", `3` = "Arm 3")) %>% 
  ggplot(aes(prop, fill = as.factor(arm), group = arm)) + 
  geom_density(alpha = 0.5) +
  geom_vline(data = actuals, aes(xintercept = prop, color = as.factor(arm)), linetype = "dashed")+
  coord_cartesian(xlim = c(0.3, 0.7))  +
  xlab("Proportion") + ylab("Denisty") +
  theme_bw() + theme(legend.title = element_blank())-> d

ggarrange(a,b,c,d, ncol = 1,nrow = 4, labels = c("A", "B", "C", "D"),
          common.legend = TRUE, legend = "bottom")




```

```{r ESBL-loo, echo = F, warning = F, message = F}

ll_m1 <- extract_log_lik(fit_mod1, merge_chains = FALSE)

r_eff_m1 <- relative_eff(exp(ll_m1)) 

ll_m2 <- extract_log_lik(fit_mod2, merge_chains = FALSE)
r_eff_m2 <- relative_eff(exp(ll_m2)) 

ll_m3 <- extract_log_lik(fit_mod3, merge_chains = FALSE)
r_eff_m3 <- relative_eff(exp(ll_m3)) 

ll_m4 <- extract_log_lik(fit_mod4, merge_chains = FALSE)
r_eff_m4 <- relative_eff(exp(ll_m4)) 

loo_mod <- list()

loo_mod[[1]] <- loo(ll_m1, r_eff = r_eff_m1, cores = 2 )
loo_mod[[2]] <- loo(ll_m2, r_eff = r_eff_m2, cores = 2 )
loo_mod[[3]] <- loo(ll_m3, r_eff = r_eff_m3, cores = 2 )
loo_mod[[4]] <- loo(ll_m4, r_eff = r_eff_m4, cores = 2 )

loo_mat <- matrix(nrow = 4, ncol = 4)
for (r in 1:4) {
  for (c in 1:4) {
    loo_temp <- loo::compare(loo_mod[[r]], loo_mod[[c]]) 
    if (r <= c) {
    loo_mat[r,c] <- glue('{specify_decimal(loo_temp[[1]],1)} ({specify_decimal(loo_temp[[2]],1)})')
     }
  }
}

loo_mat <- as.data.frame(loo_mat, stringsAsFactors = FALSE )
names(loo_mat) <- c("Model 1", "Model 2", "Model 3", "Model 4")
rownames(loo_mat) <- c("Model 1", "Model 2", "Model 3", "Model 4")
loo_mat[is.na(loo_mat)] <- "-"

kable(loo_mat, "latex", booktabs = TRUE,
      row.names = TRUE, escape = TRUE,
      caption = "Estimates (and standard error) of pairwise expected log pointwise predictive denisty differences for all models ") %>% kable_styling(full_width = FALSE) %>%
  footnote(general = "Cells in table compare row model to column model. A positive number favours the model in the column. The standard error of the ELPD difference is given in brackets; if twice the standard error is less than the estimated ELPD difference then we can be confident that the column model has better out-of-sample predictive fit than the row model. All models have better fit than model 1 but models 2-4 all have similar fit." ,threeparttable = T, fixed_small_size = T)
```

```{r mod2-params, echo = F, warning = F, message = F}

summary(fit_mod2, pars = c("alphas[1]", "betas[1]", "alphas[2]", "betas[2]", "gammas", "lambda", "mu")) -> s
as.data.frame(s$summary) -> s

s$vars <- rownames(s)

s <- dplyr::select(s,vars, `2.5%`, `50%`, `97.5%`)
# scale
s[1:4,2:4] <- exp(s[1:4,2:4])
s[5,2:4] <- s[5,2:4] * log(2)
s[6:7, 2:4] <- 1/s[6:7, 2:4] 
s[6,2:4] <- rev(s[6,2:4])
s[7,2:4] <- rev(s[7,2:4])

s$stri <- glue('{specify_decimal(s$`50%`,2)} ({specify_decimal(s$`2.5%`,2)}-{specify_decimal(s$`97.5%`,2)}) ')
s$vars <- c("Hazard ratio for ESBL-E loss", "Hazard ratio for ESBL-E acquisition",
            "Hazard ratio for ESBL-E loss", "Hazard ratio for ESBL-E acquisition",
            "Half life (days)",
            "Uncolonised (days)", "Colonised (days)")

kable(dplyr::select(s, vars, stri), "latex", booktabs = TRUE,
      row.names = FALSE, escape = FALSE, col.names = c("Variable", "Value"),
      caption = "Parameter estimates (and 95\\% confidence intervals) from model 2") %>% kable_styling(full_width = FALSE) %>%
  pack_rows("Effect of Antibacterials", 1,2) %>%
  pack_rows("Effect of Hospitalisation", 3,4) %>%
 pack_rows("Post Antibacterial Effect", 5,5) %>%
  pack_rows("Mean time in state", 6,7) %>%
  footnote(general = "Hazard ratios are the exponential of the parameters $\\\\alpha$ and $\\\\beta$ in the model; half life is equal to log(2) multiplied by $\\\\gamma$; mean time in state assumes all other covariates are equal to zero and is then the reciprocal of $\\\\lambda$ or $\\\\mu$." ,threeparttable = T, fixed_small_size = T, escape = FALSE)


```

\clearpage

### Exploring bacterial species and gentotype differences in carriage dynamics

Next, I explored the differences in carriage dynamics between ESBL-E species and _E. coli_ genotype, by refitting model 2 but considering the colonised/uncolonised states to be, in turn, presence or absence of _E. coli_, _K. pneumoniae_ or any of the top six most prevalent _E. coli_ genotypes (as defined by the combination of ESBL containing contig cluster and _E. coli_ hierBAPS cluster [Chapter xx]), and refitting the model for each one. All 993 within-participant sample-pair comparisons were used to fit the _E. coli_ and _K. pneumoniae_ models, but because sample collection continued after the sequenced _E. coli_ included here were shipped, all samples collected after this time were excluded. 585 samples from 251 participants were therefore included in the genotype models.

The parameter estimates for these eight models (alongside the original ESBL-E presence/absence model) are shown in figure \@ref(fig:bact-gen-mod-params). In general, there was more uncertainty in the parameter estimates for the new models, as might be expected as there are fewer carriage events, and fewer samples in the case of the genotype models. The only significant parameter difference between the models was in the $\lambda$ parameter, the baseline hazard of state acquisition. The magnitude of the difference was large; for example the median (95% CI) $\lambda_{ESBL}$ estimate of 0.10 (0.07-0.15) is almost three orders of magnitude larger than the estimate of $\lambda_{6.CTXM.27}$, 0.002 (0.001- 0.003). These values would correspond to a mean (95% CI) time in the uncolonised state of 10 (6-14) days for the ESBL model versus 500 (333-1000) days for the genotype model, assuming all other covariates were zero. The hazard rate of state loss, $\mu$ was similar, however, meaning that the time in the colonised state is similar for the ESBL model, and for all the _E. coli_ genotype models.

```{r bact-gen-mod-params, echo = F, warning = F, message = F,fig.scap="Parameter estimates from models of bacterial species and genotype carriage", out.extra='', fig.cap = "Parameter estimates from two state models predicting species and E. coli genotype carriage, compared to original model, which predicted carriahe of any ESBL-E. A: All parameters, showing that the only significant difference between the models is the parameter $\\lambda$ (the hazard of acquisition), with an order of magnitude difference between the hazard of ESBL acquisition versus the acqusition of a particular genotype. B: $\\lambda$ parameter only for genotype models, showing that the estimates are similar for each genotype. ",  fig.height = 10, fig.width=6,out.height = '70%',fig.align = 'center'}

mods.sum <- list()

m.esco.fit <- readRDS("chapter_9/stan_models/model_2_esco/stanfit_m2_esco.rds")


mods.sum[[1]] <- as.data.frame(summary(m.esco.fit, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[1]]$vars <- rownames(mods.sum[[1]])
mods.sum[[1]]$model <- "E. coli"
  
m.klpn.fit <- readRDS("chapter_9/stan_models/model_2_klpn/stanfit_m2_klpn.rds")

mods.sum[[2]] <- as.data.frame(summary(m.klpn.fit, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[2]]$vars <- rownames(mods.sum[[1]])
mods.sum[[2]]$model <- "K. Pneumoniae"

m.1.ctxm15.16 <- readRDS("chapter_9/stan_models/model_2_1_ctxm15_16/stanfit_m2_1_ctxm15_16.rds")

mods.sum[[3]] <- as.data.frame(summary(m.1.ctxm15.16, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[3]]$vars <- rownames(mods.sum[[1]])
mods.sum[[3]]$model <- "1.ctxm15.16"


m.6.ctxm15.27 <- readRDS("chapter_9/stan_models/model_2_6_ctxm27_1/stanfit_m2_6_ctxm27_1.rds")

mods.sum[[4]] <- as.data.frame(summary(m.6.ctxm15.27, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[4]]$vars <- rownames(mods.sum[[1]])
mods.sum[[4]]$model <- "6.ctxm15.27"

m.8.ctxm15.27 <- readRDS("chapter_9/stan_models/model_2_8_ctxm27_1/stanfit_m2_8_ctxm27_1.rds")

mods.sum[[5]] <- as.data.frame(summary(m.8.ctxm15.27, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[5]]$vars <- rownames(mods.sum[[1]])
mods.sum[[5]]$model <- "8.ctxm15.27"

m.9.ctxm15.62 <- readRDS("chapter_9/stan_models/model_2_9_ctxm15_62/stanfit_m2_9_ctxm15_62.rds")

mods.sum[[6]] <- as.data.frame(summary(m.9.ctxm15.62, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[6]]$vars <- rownames(mods.sum[[1]])
mods.sum[[6]]$model <- "9.ctxm15.62"

m.23.ctxm15.57 <- readRDS("chapter_9/stan_models/model_2_23_ctxm15_57/stanfit_m2_23_ctxm15_57.rds")

mods.sum[[7]] <- as.data.frame(summary(m.23.ctxm15.57, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[7]]$vars <- rownames(mods.sum[[1]])
mods.sum[[7]]$model <- "23.ctxm15.57"

m.39.ctxm15.57 <- readRDS("chapter_9/stan_models/model_2_39_ctxm15_22/stanfit_m2_39_ctxm15_22.rds")

mods.sum[[8]] <- as.data.frame(summary(m.39.ctxm15.57, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[8]]$vars <- rownames(mods.sum[[1]])
mods.sum[[8]]$model <- "39.ctxm15.57"

fit_mod2 <- readRDS("chapter_9/stan_models/model_2/stanfit_m2.rds")

mods.sum[[9]] <- as.data.frame(summary(fit_mod2, pars = c("alphas", "betas","lambda", "mu", "gammas" ))$summary)
mods.sum[[9]]$vars <- rownames(mods.sum[[1]])
mods.sum[[9]]$model <- "ESBL"


mods.sum <- do.call(rbind, mods.sum)

mods.sum$model<- factor(mods.sum$model, levels = rev(c("ESBL", "E. coli",
                                                   "K. Pneumoniae",
                                                   grep("ctxm", unique(mods.sum$model), 
                                                        value = TRUE))))

mods.sum$vars <- recode_factor(mods.sum$vars,
                               `mu` = "mu",
                               `lambda` = "lambda",
                               `alphas[1]` = "alpha[abx]",
                               `alphas[2]` = "alpha[hosp]",
                               `betas[1]` = "beta[abx]",
                               `betas[2]` = "beta[hosp]",
                               `gammas[1]` = "gamma"
                               )
mods.sum %>% #filter(grepl("ctxm", model) | model == "ESBL_mod2") %>%
ggplot(aes(model, `50%`, ymin = `2.5%`, ymax = `97.5%`)) +
  geom_point() + geom_errorbar(width = 0) + theme_bw() + coord_flip() + facet_wrap(~vars, scales = "free_x", ncol = 2) +
  ylab("Parameter value") +
  xlab("Model") +
  theme(panel.spacing.x = unit(1, "lines")) -> p1

mods.sum %>% filter(grepl("ctxm", model), vars %in% c("lambda")) %>%
  ggplot(aes(model, `50%`, ymin = `2.5%`, ymax = `97.5%`)) +
  geom_point() + geom_errorbar(width = 0) + theme_bw() + coord_flip() + facet_wrap(~vars, scales = "free_x", ncol = 2) +
  ylab("Parameter value") +
  xlab("Model") +
  theme(panel.spacing.x = unit(1, "lines")) -> p2

ggarrange(p1,ggarrange(NULL,p2,NULL, widths = c(0.4,1,0.4), 
                       ncol = 3, nrow = 1, labels = c(NA,"B", NA)),
          ncol = 1, nrow = 2, heights = c(4,1), labels = c("A",NA))


```

### Simulation of different antibacterial and hospitalisation scenarios

Finally, to better understand the relative roles of antimicrobial exposure and hospitalisation in driving ESBL-E carriage, I simulated the probability of ESBL-E colonisation as antibacterial and hospital exposure changed from 1 to 20 days, assuming a 50% baseline probability of ESBL-E colonisation (Figure \@ref(fig:ESBL-simul)) and both with and without cotrimoxazole preventative therapy (CPT). Hospitalisation seems to be the primary determinent of the rapid initial increase in carriage probability, with a lesser effect of antimicrobial exposure, and CPT seems to be the primary driver of an increased long-term carriage probability. In this mode, TB therapy and CPT are included in the composite "antibacterial" variable, so these conclusions would be equally valid for TB therapy.

```{r ESBL-simul, echo = F, warning = F, message = F,fig.scap= "Simulations of different antibacterial and hospitalisation scenarios", out.extra='', fig.cap = "Simulations of different antibacterial and hospitalisation scenarios. CPT = Cotrimoxazole preventative therapy. Plots show estimated probability of being in the ESBL+ state for given covariate values as a function of time, assuming a baseline 50\\% probability of ESBL-E colonisation. Antimicrobial exposure ranges across columns from 1 to 20 days, and hospitalisation across rows from 1 to 20 days. Hospitaliation is clearly the primary driver of rapid initial increase in probability, wheras antimicrobial exposure in the form of CPT is the primary deteriminent of increased long-term carriage probability.",  fig.height = 8, fig.width=10,,fig.align = 'center'}

outsum <- read.csv("chapter_9/simulations.csv", stringsAsFactors = FALSE)

outsum$hosp_days_str <- factor(outsum$hosp_days_str, levels = unique(outsum$hosp_days_str[order(outsum$hosp_days)]))
outsum$abx_days_str <- factor(outsum$abx_days_str, levels = unique(outsum$abx_days_str[order(outsum$abx_days)]))

ggplot(outsum, aes(time, median, ymin = lq, ymax = uq, group = abx_cpt, linetype = as.factor(abx_cpt))) +
  geom_line() + geom_ribbon(alpha = 0.2, color = NA) + facet_grid(hosp_days_str ~ abx_days_str) + theme_bw() + theme(legend.title = element_blank(), panel.spacing = unit(1, "line")) + scale_linetype_manual(values = c("dotted", "solid")) + xlab("Time (days") + ylab("Pr(ESBL)")


```


## Discussion

In this chapter, I have extended the continuous-time Markov models available in the _msm_ package in R to incorporate true time-varying covariates (rather than stepwise constant). I ahave fitted them to the data presented in Chapter 5 using a Bayesian framework and a differential equation solver in the probabalistic programming language Stan. From these models, it is possible to draw several conclusions.

First, the class of models that I present are feasible to fit in a reasonable amount of time with modest computational requirements, and are very flexble. The models were largely fit overnight on the WSI cluster with four cores and 3GB RAM. These are not particularly onerous requirements, and the times to fit would be expected to be similar on a desktop machine. The parameterisation of the model is extremely flexible; I chose an exponential form of a post-antibacterial effect but any functional form could be used, simply by replacing the function that generates the covariate values, $x(t)$ in Stan model. If a function can be written down, it can be fitted in this framework with minimal effort. This provides, for example, the opportunity to explore _in silico_ different hypotheses as to the ways in which antimicrobial exposure drives ESBL-E carriage, by exploring the functional form of the antimicrobial exposure covariate that best fits the data.
 
Second, the values of the parameter estimates and the simulations from the ESBL models allow an insight into the drivers of ESBL-E colonisation in Malawian adults. Hospitalisation acts to increase both ESBL-E acquisition and loss, the net result of which is a rapid increase in the probability of ESBL-E colonisation following admission. Antimicrobial exposure acts to reduce the rate of ESBL-E loss and thus prolong carriage, but it appears, from the models, that the dominant driver of rapid increase in ESBL-E prevalence seen in sepsis participants in the study is hospitalisation rather than antibacterial exposure. Some care must be taken with these conclusions both due to the fact that the parameter estimates have wide confidence intervals and the poor fit of arm 2 of the study may indicate unmeasured confounders - see limitations, below - but these associations are certainly biologically plausible. The hospital environment at QECH is such that cleaning is diffcult, hand washing facilites for staff, participants and guardians are lacking, wards are crowded with participants close together, and with one shared toilet between around 60 patients, all of which potentially facilitate the acquisition of ESBL-E. The genomics data (Chapter 6) suggests that there is no one hospital clone and in terms of _E. coli_ diversity at least, the hospital is an extension of the community. Given the number of adult admissions to QECH per year - around 15,000[ref borgstein HIV paper], this is perhaps not surprising: if each adult admission is cared for by two guardians then 5% of the population of Blantyre -  800,000 at the 2018 census - is passing through QECH yearly and the models presented here suggest that QECH may be playing a significant role in driving the high prevalence on ESBL-E carriage in Blantyre. In this situation hospital infection prevention and control (IPC) measures could potentially make a significant impact on the transmission of ESBL-E in Blantyre. Evidnce based IPC measures that can be deployed in very resource-limited settings such as QECH are urgently needed.

The models suggest that antimicrobials administered as treatment for sepsis certainly have an effect on increasing the participant-days of ESBL-E carriage in the cohort, but that this is likely less than the effect of hospitalisation. The role of CPT in driving long-term ESBL-E carriage, on the other hand seems more significant, and appears to be a major determinent of long-term ESBL-E colonisation. Again, this is perhaps not surprising given that cotrimoxazole exposure dwarfs exposure to all other antimicrobials combined in the cohort. CPT has been shown to have significant mortality benefits in people living with HIV[ref], and lifelong CPT is mandated by Malawian HIV guidelines for all people living with HIV. Given an estimated adult Malawian HIV prevalence of 9.6%, CPT is likely therefore a major driver of ESBL-E carriage in Malawi. The risk of driving AMR with CPT needs to be balanced against its benefits, and may be possible that in the era of high ART coverage, reducing malaria incidence and growing Gram-negative resistance that these risks begin to outweigh the benefits. The exact mechanism by which CPT improves mortality - whether it acts primarily to prevent bacterial infections or malaria - remans controversial. A recent RCT in Uganda in 2012 showed that a strategy of stopping CPT once the CD4 cell count is persistently above 250 cells $\mu L^{-1}$ is associated with more CPT-preventable infections, including malaria and pneumonia, but no difference in mortality (1.7% vs 1.8% over 12 months). Results are awaited of the TSCQ trial, which has assessed the effect of mortality of CPT versus chloraquine malaria prophylaxis in Malwian HIV-infected adults. Given the findings here, the latter strategy could sigificantly impact ESBL-E carriage prevalence (and hence, possibly, infections) and would be very attractive from this perspective if noninferior to CPT in mortality endpoints. 

Third, data support a post-exposure effect of antibacterials on prolonging ESBL-E carriage duration, justifying the choice of time-inhomogenous Markov models to model this system. The post-antibacterial effect has a lengthy half life of 44 days (95% credible interval 15-98 days), much longer than the time by which most antimicrobials will have been excreted from the body. Such a prolonged effect is biologically plausible, however: even short courses of antimicrobials are known to profoundly alter the composition of the gut microbiota, which could certainly alter ESBL-E carriage dynamics, and immediately sugegst the possibility of microbiota-modulation therapies to mitigate against the effect of antibacterials on ESBL-E carriage. Further studies of the role of the microbiota in colonisation resistance to ESBL-E could shed light on the mechanisms of the post-antibacterial effect I demonstrate here, and pave the way for such interventions.

Fourth, using WGS as a high resolution typing tool allows very granular insight into ESBL-E carriage at the genotype level. Within the limitations of reasonably uncertain parameter estimates due to small numbers, all parameters for genotype carriage models were the same as the general ESBL carriage model, with the exception of $\lambda$. This indicates that the rate of aquisition of a given _E. coli_ genotype is two to three orders of magnitude lower then the overall rate of ESBL acquistion, which suggests that apparent continual ESBL-E carriage in fact represents a much more frequent apparent acquisition of different ESBL-E genotypes. This could represent true acquisition or some other dynamic shift in the relative abundance of ESBL producing _E. coli_ in the microbiota over time. This analysis is, however, hampered by the fact that only one colony at each time point was sequenced and hence the true distribution of _E. coli_ genotypes at a given time point is unknown - see limitations, below.

### Limitations


Post antibacterial effect


parameter estimates
Some care is warranted in interpreting this finding as a lack of effect of antimicrobial exposure on ESBL-E acquisition, however: firstly, the credible intervals cover a relevent effect size, and secondly, for cotrimoxazole in particular, in many models $\beta$ has a reasonably high probability of being different than zero. For example in Model 3 (Figure \@ref(fig:ESBL-twostate-diag)C) the 80% credible interval for $\beta_{cotrimoxazole}$ does not cross zero, meaning there is an 80% probability that $\beta_{cotrimoxazole}$ is different from zero. Nevertheless, given these parameter estimates we can have good confidence in the conclusion that, (conditional on the models and assumptions made) hospitalisation acts to increase both ESBL-E acquisition and loss, and antibacterial exposure acts to reduce ESBL-E loss, and moderate confidence
wide confidence intervals incorporate clinically relevent effects even when cross 0

poor fit to arm 2 and 3 - is hospitalisation really the thing or is there confoundig

Wide CIs for cipro, cefo, amoxy - difficult to assess roles of individual agents

models are parameter hungry - more parameters, more uncertainty

Imperfect tests - hidden markov model needed

Censor states - multiple carriage

Interactions - effect of abx different in hospital?

## Conclusion and further work